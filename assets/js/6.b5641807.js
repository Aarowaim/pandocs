(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{210:function(e,t,a){"use strict";a.r(t);var r=a(0),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"pan-docs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pan-docs"}},[e._v("#")]),e._v(" Pan Docs")]),e._v(" "),a("h4",{attrs:{id:"table-of-contents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#table-of-contents"}},[e._v("#")]),e._v(" Table of Contents")]),e._v(" "),a("p",[e._v("Overview")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#about-the-pan-docs"}},[e._v("About the Pan Docs")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#specifications"}},[e._v("Specifications")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#memory-map"}},[e._v("Memory Map")])])]),e._v(" "),a("p",[e._v("I/O Ports")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#video-display"}},[e._v("Video Display")])]),e._v(" "),a("li",[e._v("Sound Controller")]),e._v(" "),a("li",[e._v("Joypad Input")]),e._v(" "),a("li",[e._v("Serial Data Transfer (Link Cable)")]),e._v(" "),a("li",[e._v("Timer and Divider Registers")]),e._v(" "),a("li",[e._v("Interrupts")]),e._v(" "),a("li",[e._v("CGB Registers")]),e._v(" "),a("li",[e._v("SGB Functions")])]),e._v(" "),a("p",[e._v("CPU Specifications")]),e._v(" "),a("ul",[a("li",[e._v("Registers and Flags")]),e._v(" "),a("li",[e._v("Instruction Set")]),e._v(" "),a("li",[e._v("Comparision with Z80")])]),e._v(" "),a("p",[e._v("Cartridges")]),e._v(" "),a("ul",[a("li",[e._v("Cartridge header")]),e._v(" "),a("li",[e._v("MBC1")]),e._v(" "),a("li",[e._v("MBC2")]),e._v(" "),a("li",[e._v("MBC3")]),e._v(" "),a("li",[e._v("MBC5")]),e._v(" "),a("li",[e._v("MBC6")]),e._v(" "),a("li",[e._v("MBC7")]),e._v(" "),a("li",[e._v("HuC1")])]),e._v(" "),a("p",[e._v("Accessories")]),e._v(" "),a("ul",[a("li",[e._v("Gameboy Printer")]),e._v(" "),a("li",[e._v("Gameboy Camera")]),e._v(" "),a("li",[e._v("Gamegenie/Shark Cheats")])]),e._v(" "),a("p",[e._v("Other")]),e._v(" "),a("ul",[a("li",[e._v("Power Up Sequence")]),e._v(" "),a("li",[e._v("Reducing Power Consumption")]),e._v(" "),a("li",[e._v("Sprite RAM Bug")]),e._v(" "),a("li",[e._v("External Connectors")])]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"about-the-pan-docs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#about-the-pan-docs"}},[e._v("#")]),e._v(" About the Pan Docs")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" =================================================================\n       Everything You Always Wanted To Know About GAMEBOY *\n =================================================================\n\n                     * but were afraid to ask\n")])])]),a("p",[e._v("This is a new, experimental version of Pan Docs, mantained in the Markdown format.")]),e._v(" "),a("p",[e._v("To learn more about the History and the current mission of the project, check the "),a("a",{attrs:{href:"https://github.com/gbdev/pandocs#history",target:"_blank",rel:"noopener noreferrer"}},[e._v("README"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h1",{attrs:{id:"specifications"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specifications"}},[e._v("#")]),e._v(" Specifications")]),e._v(" "),a("ul",[a("li",[e._v("CPU - 8-bit Sharp LR25902 (similar to the Z80 processor)")]),e._v(" "),a("li",[e._v("Clock Speed - 4.194304MHz (4.295454MHz for SGB, max. 8.4MHz for CGB)")]),e._v(" "),a("li",[e._v("Work RAM - 8K Byte (32K Byte for CGB)")]),e._v(" "),a("li",[e._v("Video RAM - 8K Byte (16K Byte for CGB)")]),e._v(" "),a("li",[e._v('Screen Size - 2.6"')]),e._v(" "),a("li",[e._v("Resolution - 160x144 (20x18 tiles)")]),e._v(" "),a("li",[e._v("Max sprites - Max 40 per screen, 10 per line")]),e._v(" "),a("li",[e._v("Sprite sizes - 8x8 or 8x16 pixels")]),e._v(" "),a("li",[e._v("Palettes - 1x4 BG, 2x3 OBJ (for CGB: 8x4 BG, 8x3 OBJ)")]),e._v(" "),a("li",[e._v("Colors - 4 grayshades (32768 colors for CGB)")]),e._v(" "),a("li",[e._v("Horiz Sync - 9198 KHz (9420 KHz for SGB)")]),e._v(" "),a("li",[e._v("Vert Sync - 59.73 Hz (61.17 Hz for SGB)")]),e._v(" "),a("li",[e._v("Sound - 4 channels with stereo sound")]),e._v(" "),a("li",[e._v("Power - DC6V 0.7W (DC3V 0.7W for GB Pocket, DC3V 0.6W for CGB)")])]),e._v(" "),a("h1",{attrs:{id:"memory-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#memory-map"}},[e._v("#")]),e._v(" Memory Map")]),e._v(" "),a("p",[e._v("The gameboy has a 16bit address bus, that is used to address ROM, RAM and I/O")]),e._v(" "),a("h2",{attrs:{id:"general-memory-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#general-memory-map"}},[e._v("#")]),e._v(" General Memory Map")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("strong",[e._v("Start")])]),e._v(" "),a("th",[a("strong",[e._v("End")])]),e._v(" "),a("th",[a("strong",[e._v("Description")])]),e._v(" "),a("th",[a("strong",[e._v("Notes")])])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("0000")]),e._v(" "),a("td",[e._v("3FFF")]),e._v(" "),a("td",[e._v("16KB ROM bank 00")]),e._v(" "),a("td",[e._v("From cartridge, usually a fixed bank")])]),e._v(" "),a("tr",[a("td",[e._v("4000")]),e._v(" "),a("td",[e._v("7FFF")]),e._v(" "),a("td",[e._v("16KB ROM Bank 01~NN")]),e._v(" "),a("td",[e._v("From cartridge, switchable bank via "),a("a",{attrs:{href:"Memory_Bank_Controllers",title:"wikilink"}},[e._v("MB")]),e._v(" (if any)")])]),e._v(" "),a("tr",[a("td",[e._v("8000")]),e._v(" "),a("td",[e._v("9FFF")]),e._v(" "),a("td",[e._v("8KB Video RAM (VRAM)")]),e._v(" "),a("td",[e._v("Only bank 0 in Non-CGB mode Switchable bank 0/1 in CGB mode")])]),e._v(" "),a("tr",[a("td",[e._v("A000")]),e._v(" "),a("td",[e._v("BFFF")]),e._v(" "),a("td",[e._v("8KB External RAM")]),e._v(" "),a("td",[e._v("In cartridge, switchable bank if any")])]),e._v(" "),a("tr",[a("td",[e._v("C000")]),e._v(" "),a("td",[e._v("CFFF")]),e._v(" "),a("td",[e._v("4KB Work RAM (WRAM) bank 0")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("D000")]),e._v(" "),a("td",[e._v("DFFF")]),e._v(" "),a("td",[e._v("4KB Work RAM (WRAM) bank 1~N")]),e._v(" "),a("td",[e._v("Only bank 1 in Non-CGB mode Switchable bank 1~7 in CGB mode")])]),e._v(" "),a("tr",[a("td",[e._v("E000")]),e._v(" "),a("td",[e._v("FDFF")]),e._v(" "),a("td",[e._v("Mirror of C000~DDFF (ECHO RAM)")]),e._v(" "),a("td",[e._v("Typically not used")])]),e._v(" "),a("tr",[a("td",[e._v("FE00")]),e._v(" "),a("td",[e._v("FE9F")]),e._v(" "),a("td",[e._v("Sprite attribute table ("),a("a",{attrs:{href:"Video_Display#VRAM_Sprite_Attribute_Table_.28OAM.29",title:"wikilink"}},[e._v("OAM")]),e._v(")")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("FEA0")]),e._v(" "),a("td",[e._v("FEFF")]),e._v(" "),a("td",[e._v("Not Usable")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("FF00")]),e._v(" "),a("td",[e._v("FF7F")]),e._v(" "),a("td",[e._v("I/O Registers")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("FF80")]),e._v(" "),a("td",[e._v("FFFE")]),e._v(" "),a("td",[e._v("High RAM (HRAM)")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[e._v("FFFF")]),e._v(" "),a("td",[e._v("FFFF")]),e._v(" "),a("td",[a("a",{attrs:{href:"Interrupts",title:"wikilink"}},[e._v("Interrupts")]),e._v(" Enable Register (IE)")]),e._v(" "),a("td")])])]),e._v(" "),a("h2",{attrs:{id:"jump-vectors-in-first-rom-bank"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jump-vectors-in-first-rom-bank"}},[e._v("#")]),e._v(" Jump Vectors in first ROM bank")]),e._v(" "),a("p",[e._v("The following addresses are supposed to be used as jump vectors:")]),e._v(" "),a("ul",[a("li",[e._v("RST commands: 0000,0008,0010,0018,0020,0028,0030,0038")]),e._v(" "),a("li",[e._v("Interrupts: 0040,0048,0050,0058,0060")])]),e._v(" "),a("p",[e._v("However, the memory may be used for any other purpose in case that your\nprogram doesn't use any (or only some) RST commands or interrupts. RST\ncommands are 1-byte opcodes that work similar to CALL opcodes, except\nthat the destination address is fixed. Since they are only 1 byte large,\nthey are also slightly faster.")]),e._v(" "),a("h2",{attrs:{id:"cartridge-header-in-first-rom-bank"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cartridge-header-in-first-rom-bank"}},[e._v("#")]),e._v(" Cartridge Header in first ROM bank")]),e._v(" "),a("p",[e._v("The memory at 0100-014F contains the "),a("a",{attrs:{href:"The_Cartridge_Header",title:"wikilink"}},[e._v("cartridge\nheader")]),e._v(". This area contains information\nabout the program, its entry point, checksums, information about the\nused MBC chip, the ROM and RAM sizes, etc. Most of the bytes in this\narea are required to be specified correctly. For more information read\nthe chapter about The Cartridge Header.")]),e._v(" "),a("h2",{attrs:{id:"external-memory-and-hardware"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#external-memory-and-hardware"}},[e._v("#")]),e._v(" External Memory and Hardware")]),e._v(" "),a("p",[e._v("The areas from 0000-7FFF and A000-BFFF may be used to connect external\nhardware. The first area is typically used to address ROM (read only, of\ncourse), cartridges with "),a("a",{attrs:{href:"Memory_Bank_Controllers",title:"wikilink"}},[e._v("Memory Bank Controllers\n(MBCs)")]),e._v(" are additionally using this\narea to output data (write only) to the MBC chip. The second area is\noften used to address external RAM, or to address other external\nhardware ("),a("a",{attrs:{href:"RTC",title:"wikilink"}},[e._v("Real Time Clock")]),e._v(", etc). External memory is\noften battery buffered, and may hold saved game positions and high score\ntables (etc.) even when the Game Boy is turned off, or when the\ncartridge is removed. For specific information read the chapter about\nMemory Bank Controllers.")]),e._v(" "),a("h2",{attrs:{id:"echo-ram"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#echo-ram"}},[e._v("#")]),e._v(" Echo RAM")]),e._v(" "),a("p",[e._v("The memory range E000-FDFF is a mirror (or \"echo\") of WRAM, both for\nreading and writing. For example, writing to $E123 will modify both\n$C123 and $E123. It is recommended to avoid using this memory range\nanyways. This memory range's behavior has been confirmed on all grey\nGBs as well as on CGB and GBA. Some emulators (such as VisualBoyAdvance\n<1.8) don't emulate Echo RAM. It is possible to check if Echo RAM is\nproperly emulated by writing to WRAM (avoid values 00 and FF) and\nchecking if said value is mirrored in Echo RAM.")]),e._v(" "),a("h2",{attrs:{id:"fea0-feff-range"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fea0-feff-range"}},[e._v("#")]),e._v(" FEA0-FEFF range")]),e._v(" "),a("p",[e._v("This range is very poorly documented. It doesn't even have a name !\nFrom my experience, this stays 00 on DMG, and alternates between 00 and\nseemingly random values on CGB.")]),e._v(" "),a("h1",{attrs:{id:"video-display"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#video-display"}},[e._v("#")]),e._v(" Video Display")]),e._v(" "),a("h2",{attrs:{id:"lcd-control-register"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-control-register"}},[e._v("#")]),e._v(" LCD Control Register")]),e._v(" "),a("p",[e._v("Detailed article: "),a("a",{attrs:{href:"LCDC",title:"wikilink"}},[e._v("LCDC")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Bit 7 - LCD Display Enable             (0=Off, 1=On)\nBit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)\nBit 5 - Window Display Enable          (0=Off, 1=On)\nBit 4 - BG & Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)\nBit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)\nBit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)\nBit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)\nBit 0 - BG/Window Display/Priority     (0=Off, 1=On)\n")])])]),a("h2",{attrs:{id:"lcd-status-register"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-status-register"}},[e._v("#")]),e._v(" LCD Status Register")]),e._v(" "),a("h4",{attrs:{id:"ff41-stat-lcdc-status-r-w"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff41-stat-lcdc-status-r-w"}},[e._v("#")]),e._v(" FF41 - STAT - LCDC Status (R/W)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)\nBit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)\nBit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)\nBit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)\nBit 2 - Coincidence Flag  (0:LYC<>LY, 1:LYC=LY) (Read Only)\nBit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)\n          0: During H-Blank\n          1: During V-Blank\n          2: During Searching OAM\n          3: During Transferring Data to LCD Driver\n")])])]),a("p",[e._v("The two lower STAT bits show the current status of the LCD controller.")]),e._v(" "),a("p",[e._v("The LCD controller operates on a 2^22^ Hz = 4.194 MHz dot clock. An\nentire frame is 154 scanlines, 70224 dots, or 16.74 ms. On scanlines 0\nthrough 143, the LCD controller cycles through modes 2, 3, and 0 once\nevery 456 dots. Scanlines 144 through 153 are mode 1.")]),e._v(" "),a("p",[e._v("The following are typical when the display is enabled:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Mode 2  2_____2_____2_____2_____2_____2___________________2____\nMode 3  _33____33____33____33____33____33__________________3___\nMode 0  ___000___000___000___000___000___000________________000\nMode 1  ____________________________________11111111111111_____\n")])])]),a("p",[e._v("When the LCD controller is reading a particular part of video memory,\nthat memory is inaccessible to the CPU.")]),e._v(" "),a("ul",[a("li",[e._v("During modes 2 and 3, the CPU cannot access OAM (FE00h-FE9Fh).")]),e._v(" "),a("li",[e._v("During mode 3, the CPU cannot access VRAM or CGB Palette Data\n(FF69,FF6B).")])]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Mode")]),e._v(" "),a("th",[e._v("Action")]),e._v(" "),a("th",[e._v("Duration")]),e._v(" "),a("th",[e._v("Accessible video memory")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("2")]),e._v(" "),a("td",[e._v("Scanning OAM for (X, Y) coordinates of sprites that overlap this line")]),e._v(" "),a("td",[e._v("80 dots (19 us)")]),e._v(" "),a("td",[e._v("VRAM, CGB palettes")])]),e._v(" "),a("tr",[a("td",[e._v("3")]),e._v(" "),a("td",[e._v("Reading OAM and VRAM to generate the picture")]),e._v(" "),a("td",[e._v("168 to 291 cycles (40 to 60 us) depending on sprite count")]),e._v(" "),a("td",[e._v("None")])]),e._v(" "),a("tr",[a("td",[e._v("0")]),e._v(" "),a("td",[e._v("Horizontal blanking")]),e._v(" "),a("td",[e._v("85 to 208 dots (20 to 49 us) depending on previous mode 3 duration")]),e._v(" "),a("td",[e._v("VRAM, OAM, CGB palettes")])]),e._v(" "),a("tr",[a("td",[e._v("1")]),e._v(" "),a("td",[e._v("Vertical blanking")]),e._v(" "),a("td",[e._v("4560 dots (1087 us, 10 scanlines)")]),e._v(" "),a("td",[e._v("VRAM, OAM, CGB palettes")])])])]),e._v(" "),a("p",[e._v(": Properties of STAT modes")]),e._v(" "),a("p",[e._v("Unlike most game consoles, the Game Boy can pause the dot clock briefly,\nadding dots to mode 3's duration. It routinely takes a 6 to 11 dot\nbreak to fetch sprite patterns between background tile pattern fetches.\nOn DMG and GBC in DMG mode, mid-scanline writes to "),a("code",[e._v("BGP")]),e._v(" allow observing\nthis behavior, as a sprite delay shifts the effect of a write to the\nleft by that many dots.")]),e._v(" "),a("p",[e._v("Three things are known to pause the dot clock:")]),e._v(" "),a("p",[e._v("Background scrolling\n:   If "),a("code",[e._v("SCX mod 8")]),e._v(" is not zero at the start of the scanline, rendering\nis paused for that many dots while the shifter discards that many\npixels from the leftmost tile.")]),e._v(" "),a("p",[e._v("Window\n:   An active window pauses for at least 6 dots, as the background\nfetching mechanism starts over at the left side of the window.")]),e._v(" "),a("p",[e._v("Sprites\n:   Each sprite usually pauses for "),a("code",[e._v("11 - min(5, (x + SCX) mod 8)")]),e._v(" dots.\nBecause sprite fetch waits for background fetch to finish, a\nsprite's cost depends on its position relative to the left side of\nthe background tile under it. It's greater if a sprite is directly\naligned over the background tile, less if the sprite is to the\nright. If the sprite's left side is over the window, use "),a("code",[e._v("255 - WX")]),e._v("\nfor "),a("code",[e._v("SCX")]),e._v(" in this formula.")]),e._v(" "),a("p",[a("strong",[e._v("Not fully understood:")]),e._v(" The exact pause duration for window start is\nnot confirmed; it may have the same background fetch finish delay as a\nsprite. If two sprites' left sides are over the same background or\nwindow tile, the second may pause for fewer dots.")]),e._v(" "),a("p",[e._v("A hardware quirk in the monochrome Game Boy makes the LCD interrupt\nsometimes trigger when writing to STAT (including writing $00) during\nOAM scan, H-Blank, V-Blank, or LY=LYC. It behaves as if $FF were\nwritten for one cycle, and then the written value were written the next\ncycle. Because the GBC in DMG mode does not have this quirk, two games\nthat depend on this quirk (Ocean's "),a("em",[e._v("Road Rash")]),e._v(" and Vic Tokai's "),a("em",[e._v("Xerd\nno Densetsu")]),e._v(") will not run on a GBC.")]),e._v(" "),a("h2",{attrs:{id:"lcd-interrupts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-interrupts"}},[e._v("#")]),e._v(" LCD Interrupts")]),e._v(" "),a("h4",{attrs:{id:"int-40-v-blank-interrupt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#int-40-v-blank-interrupt"}},[e._v("#")]),e._v(" INT 40 - V-Blank Interrupt")]),e._v(" "),a("p",[e._v("The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game\nBoy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a\nSuper Game Boy (SGB). This interrupt occurs at the beginning of the\nV-Blank period (LY=144). During this period video hardware is not using\nVRAM so it may be freely accessed. This period lasts approximately 1.1\nmilliseconds.")]),e._v(" "),a("h4",{attrs:{id:"int-48-lcdc-status-interrupt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#int-48-lcdc-status-interrupt"}},[e._v("#")]),e._v(" INT 48 - LCDC Status Interrupt")]),e._v(" "),a("p",[e._v("There are various reasons for this interrupt to occur as described by\nthe STAT register ($FF40). One very popular reason is to indicate to\nthe user when the video hardware is about to redraw a given LCD line.\nThis can be useful for dynamically controlling the SCX/SCY registers\n($FF43/$FF42) to perform special video effects.")]),e._v(" "),a("p",[e._v("Example application : set LYC to WY, enable LY=LYC interrupt, and have\nthe handler disable sprites. This can be used if you use the window for\na text box (at the bottom of the screen), and you want sprites to be\nhidden by the text box.")]),e._v(" "),a("p",[e._v('The interrupt is triggered when transitioning from "No conditions met"\nto "Any condition met", which can cause the interrupt to not fire.\nExample : the Mode 0 and LY=LYC interrupts are enabled ; since the\nlatter triggers during Mode 2 (right after Mode 0), the interrupt will\ntrigger for Mode 0 but fail to for LY=LYC.')]),e._v(" "),a("h2",{attrs:{id:"lcd-position-and-scrolling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-position-and-scrolling"}},[e._v("#")]),e._v(" LCD Position and Scrolling")]),e._v(" "),a("p",[e._v("These registers can be accessed even during Mode 3, but they have no\neffect until the end of the current scanline.")]),e._v(" "),a("h4",{attrs:{id:"ff42-scy-scroll-y-r-w-ff43-scx-scroll-x-r-w"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff42-scy-scroll-y-r-w-ff43-scx-scroll-x-r-w"}},[e._v("#")]),e._v(" FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W)")]),e._v(" "),a("p",[e._v("Specifies the position in the 256x256 pixels BG map (32x32 tiles) which\nis to be displayed at the upper/left LCD display position. Values in\nrange from 0-255 may be used for X/Y each, the video controller\nautomatically wraps back to the upper (left) position in BG map when\ndrawing exceeds the lower (right) border of the BG map area.")]),e._v(" "),a("h4",{attrs:{id:"ff44-ly-lcdc-y-coordinate-r"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff44-ly-lcdc-y-coordinate-r"}},[e._v("#")]),e._v(" FF44 - LY - LCDC Y-Coordinate (R)")]),e._v(" "),a("p",[e._v("The LY indicates the vertical line to which the present data is\ntransferred to the LCD Driver. The LY can take on any value between 0\nthrough 153. The values between 144 and 153 indicate the V-Blank period.")]),e._v(" "),a("h4",{attrs:{id:"ff45-lyc-ly-compare-r-w"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff45-lyc-ly-compare-r-w"}},[e._v("#")]),e._v(" FF45 - LYC - LY Compare (R/W)")]),e._v(" "),a("p",[e._v("The Gameboy permanently compares the value of the LYC and LY registers.\nWhen both values are identical, the coincident bit in the STAT register\nbecomes set, and (if enabled) a STAT interrupt is requested.")]),e._v(" "),a("h4",{attrs:{id:"ff4a-wy-window-y-position-r-w-ff4b-wx-window-x-position-minus-7-r-w"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff4a-wy-window-y-position-r-w-ff4b-wx-window-x-position-minus-7-r-w"}},[e._v("#")]),e._v(" FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W)")]),e._v(" "),a("p",[e._v("Specifies the upper/left positions of the Window area. (The window is an\nalternate background area which can be displayed above of the normal\nbackground. OBJs (sprites) may be still displayed above or behind the\nwindow, just as for normal BG.)")]),e._v(" "),a("p",[e._v("The window becomes visible (if enabled) when positions are set in range\nWX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at\nupper left, it is then completely covering normal background.")]),e._v(" "),a("p",[e._v('WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set\nto 0, the window will "stutter" horizontally when SCX changes.\n(Depending on SCX modulo 8, behavior is a little complicated so you\nshould try it yourself.)')]),e._v(" "),a("h2",{attrs:{id:"lcd-monochrome-palettes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-monochrome-palettes"}},[e._v("#")]),e._v(" LCD Monochrome Palettes")]),e._v(" "),a("h4",{attrs:{id:"ff47-bgp-bg-palette-data-r-w-non-cgb-mode-only"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff47-bgp-bg-palette-data-r-w-non-cgb-mode-only"}},[e._v("#")]),e._v(" FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only")]),e._v(" "),a("p",[e._v("This register assigns gray shades to the color numbers of the BG and\nWindow tiles.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Bit 7-6 - Shade for Color Number 3\nBit 5-4 - Shade for Color Number 2\nBit 3-2 - Shade for Color Number 1\nBit 1-0 - Shade for Color Number 0\n")])])]),a("p",[e._v("The four possible gray shades are:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("0  White\n1  Light gray\n2  Dark gray\n3  Black\n")])])]),a("p",[e._v("In CGB Mode the Color Palettes are taken from CGB Palette Memory\ninstead.")]),e._v(" "),a("h4",{attrs:{id:"ff48-obp0-object-palette-0-data-r-w-non-cgb-mode-only"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff48-obp0-object-palette-0-data-r-w-non-cgb-mode-only"}},[e._v("#")]),e._v(" FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only")]),e._v(" "),a("p",[e._v("This register assigns gray shades for sprite palette 0. It works exactly\nas BGP (FF47), except that the lower two bits aren't used because\nsprite data 00 is transparent.")]),e._v(" "),a("h4",{attrs:{id:"ff49-obp1-object-palette-1-data-r-w-non-cgb-mode-only"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff49-obp1-object-palette-1-data-r-w-non-cgb-mode-only"}},[e._v("#")]),e._v(" FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only")]),e._v(" "),a("p",[e._v("This register assigns gray shades for sprite palette 1. It works exactly\nas BGP (FF47), except that the lower two bits aren't used because\nsprite data 00 is transparent.")]),e._v(" "),a("h2",{attrs:{id:"lcd-color-palettes-cgb-only"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-color-palettes-cgb-only"}},[e._v("#")]),e._v(" LCD Color Palettes (CGB only)")]),e._v(" "),a("h4",{attrs:{id:"ff68-bcps-bgpi-cgb-mode-only-background-palette-index"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff68-bcps-bgpi-cgb-mode-only-background-palette-index"}},[e._v("#")]),e._v(" FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index")]),e._v(" "),a("p",[e._v("This register is used to address a byte in the CGBs Background Palette\nMemory. Each two byte in that memory define a color value. The first 8\nbytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Bit 0-5   Index (00-3F)\nBit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)\n")])])]),a("p",[e._v("Data can be read/written to/from the specified index address through\nRegister FF69. When the Auto Increment bit is set then the index is\nautomatically incremented after each "),a("strong",[e._v("write")]),e._v(" to FF69. Auto Increment has\nno effect when "),a("strong",[e._v("reading")]),e._v(" from FF69, so the index must be manually\nincremented in that case. Writing to FF69 during rendering still causes\nauto-increment to occur.")]),e._v(" "),a("p",[e._v("Unlike the following, this register can be accessed outside V-Blank and\nH-Blank.")]),e._v(" "),a("h4",{attrs:{id:"ff69-bcpd-bgpd-cgb-mode-only-background-palette-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff69-bcpd-bgpd-cgb-mode-only-background-palette-data"}},[e._v("#")]),e._v(" FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data")]),e._v(" "),a("p",[e._v("This register allows to read/write data to the CGBs Background Palette\nMemory, addressed through Register FF68. Each color is defined by two\nbytes (Bit 0-7 in first byte).")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Bit 0-4   Red Intensity   (00-1F)\nBit 5-9   Green Intensity (00-1F)\nBit 10-14 Blue Intensity  (00-1F)\n")])])]),a("p",[e._v("Much like VRAM, data in Palette Memory cannot be read/written during the\ntime when the LCD Controller is reading from it. (That is when the STAT\nregister indicates Mode 3). Note: All background colors are initialized\nas white by the boot ROM, but it's a good idea to initialize at least\none color yourself (for example if you include a soft-reset mechanic).")]),e._v(" "),a("h4",{attrs:{id:"ff6a-ocps-obpi-cgb-mode-only-sprite-palette-index-ff6b-ocpd-obpd-cgb-mode-only-sprite-palette-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff6a-ocps-obpi-cgb-mode-only-sprite-palette-index-ff6b-ocpd-obpd-cgb-mode-only-sprite-palette-data"}},[e._v("#")]),e._v(" FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data")]),e._v(" "),a("p",[e._v("These registers are used to initialize the Sprite Palettes OBP0-7,\nidentically as described above for Background Palettes. Note that four\ncolors may be defined for each OBP Palettes - but only Color 1-3 of each\nSprite Palette can be displayed, Color 0 is always transparent, and can\nbe initialized to a don't care value or plain never initialized.")]),e._v(" "),a("p",[e._v("Note: All sprite colors are left uninitialized by the boot ROM, and are\nsomewhat random.")]),e._v(" "),a("h4",{attrs:{id:"rgb-translation-by-cgbs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rgb-translation-by-cgbs"}},[e._v("#")]),e._v(" RGB Translation by CGBs")]),e._v(" "),a("p",[a("img",{attrs:{src:"VGA_versus_CGB.png",alt:"sRGB versus CGB colormixing",title:"fig:sRGB versus CGB color mixing"}}),e._v('{width="150"}\nWhen developing graphics on PCs, note that the RGB values will have\ndifferent appearance on CGB displays as on VGA/HDMI monitors calibrated\nto sRGB color. Because the GBC is not lit, the highest intensity will\nproduce Light Gray color rather than White. The intensities are not\nlinear; the values 10h-1Fh will all appear very bright, while medium and\ndarker colors are ranged at 00h-0Fh.')]),e._v(" "),a("p",[e._v("The CGB display's pigments aren't perfectly saturated. This means the\ncolors mix quite oddly; increasing intensity of only one R,G,B color\nwill also influence the other two R,G,B colors. For example, a color\nsetting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green\non VGA displays, but on the CGB it'll produce a decently washed out\nYellow. See image on the right.")]),e._v(" "),a("h4",{attrs:{id:"rgb-translation-by-gbas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rgb-translation-by-gbas"}},[e._v("#")]),e._v(" RGB Translation by GBAs")]),e._v(" "),a("p",[e._v("Even though GBA is described to be compatible to CGB games, most CGB\ngames are completely unplayable on older GBAs because most colors are\ninvisible (black). Of course, colors such like Black and White will\nappear the same on both CGB and GBA, but medium intensities are arranged\ncompletely different. Intensities in range 00h..07h are invisible/black\n(unless eventually under best sunlight circumstances, and when gazing at\nthe screen under obscure viewing angles), unfortunately, these\nintensities are regularly used by most existing CGB games for medium and\ndarker colors.")]),e._v(" "),a("p",[e._v("Newer CGB games may avoid this effect by changing palette data when\ndetecting GBA hardware ("),a("a",{attrs:{href:"CGB_Registers#Detecting_CGB_.28and_GBA.29_functions",title:"wikilink"}},[e._v("see\nhow")]),e._v(').\nBased on measurement of GBC and GBA palettes using the "144p Test\nSuite" ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for\neach R,G,B intensity. The result isn\'t quite perfect, and it may turn\nout that the color mixing is different also; anyways, it\'d be still\nways better than no conversion. Asides, this translation method should\nhave been VERY easy to implement in GBA hardware directly, even though\nNintendo obviously failed to do so. How did they say, "This seal is\nyour assurance for excellence in workmanship" and so on?')]),e._v(" "),a("p",[e._v("This problem with low brightness levels does not affect later GBA SP\nunits and Game Boy Player. Thus ideally, the player should have control\nof this brightness correction.")]),e._v(" "),a("h2",{attrs:{id:"lcd-oam-dma-transfers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-oam-dma-transfers"}},[e._v("#")]),e._v(" LCD OAM DMA Transfers")]),e._v(" "),a("h4",{attrs:{id:"ff46-dma-dma-transfer-and-start-address-r-w"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff46-dma-dma-transfer-and-start-address-r-w"}},[e._v("#")]),e._v(" FF46 - DMA - DMA Transfer and Start Address (R/W)")]),e._v(" "),a("p",[e._v("Writing to this register launches a DMA transfer from ROM or RAM to OAM\nmemory (sprite attribute table). The written value specifies the\ntransfer source address divided by 100h, ie. source & destination are:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Source:      XX00-XX9F   ;XX in range from 00-F1h\nDestination: FE00-FE9F\n")])])]),a("p",[e._v("The transfer takes 160 machine cycles: 152 microseconds in normal speed\nor 76 microseconds in CGB Double Speed Mode. On DMG, during this time,\nthe CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used\nby the source area cannot be used (this isn't understood well at the\nmoment, it's recommended to assume same behavior as DMG). For this\nreason, the programmer must copy a short procedure into HRAM, and use\nthis procedure to start the transfer from inside HRAM, and wait until\nthe transfer has finished:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" run_dma:\n  ld a, start address / 100h\n  ldh  (FF46h),a ;start DMA transfer (starts right after instruction)\n  ld  a,28h      ;delay...\n wait:           ;total 4x40 cycles, approx 160 μs\n  dec a          ;1 cycle\n  jr  nz,wait    ;3 cycles\n  ret\n")])])]),a("p",[e._v("Because sprites are not displayed while OAM DMA is in progress, most\nprograms are executing this procedure from inside of their VBlank\nprocedure. But it is also possible to execute it during display redraw\nalso, allowing to display more than 40 sprites on the screen (ie. for\nexample 40 sprites in upper half, and other 40 sprites in lower half of\nthe screen), at the cost of a couple lines that lack sprites.")]),e._v(" "),a("p",[e._v("A more compact procedure is")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" run_dma:  ; This part is in ROM\n  ld a, start address / 100h\n  ld bc, 2946h  ; B: wait time; C: OAM trigger\n  jp run_dma_hrampart\n\n run_dma_hrampart:\n  ldh ($FF00+c), a\n wait:\n  dec b\n  jr nz,wait\n  ret\n")])])]),a("p",[e._v("which should be called with a = start address / 100h, bc = 2946h. This\nsaves 5 bytes of HRAM, but is slightly slower in most cases because of\nthe jump into the HRAM part.")]),e._v(" "),a("h2",{attrs:{id:"lcd-vram-dma-transfers-cgb-only"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcd-vram-dma-transfers-cgb-only"}},[e._v("#")]),e._v(" LCD VRAM DMA Transfers (CGB only)")]),e._v(" "),a("h4",{attrs:{id:"ff51-hdma1-cgb-mode-only-new-dma-source-high"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff51-hdma1-cgb-mode-only-new-dma-source-high"}},[e._v("#")]),e._v(" FF51 - HDMA1 - CGB Mode Only - New DMA Source, High")]),e._v(" "),a("h4",{attrs:{id:"ff52-hdma2-cgb-mode-only-new-dma-source-low"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff52-hdma2-cgb-mode-only-new-dma-source-low"}},[e._v("#")]),e._v(" FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low")]),e._v(" "),a("p",[e._v("These two registers specify the address at which the transfer will read\ndata from. Normally, this should be either in ROM, SRAM or WRAM, thus\neither in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be\ntested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source\naddress in VRAM will cause garbage to be copied.")]),e._v(" "),a("p",[e._v("The four lower bits of this address will be ignored and treated as 0.")]),e._v(" "),a("h4",{attrs:{id:"ff53-hdma3-cgb-mode-only-new-dma-destination-high"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff53-hdma3-cgb-mode-only-new-dma-destination-high"}},[e._v("#")]),e._v(" FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High")]),e._v(" "),a("h4",{attrs:{id:"ff54-hdma4-cgb-mode-only-new-dma-destination-low"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff54-hdma4-cgb-mode-only-new-dma-destination-low"}},[e._v("#")]),e._v(" FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low")]),e._v(" "),a("p",[e._v("These two registers specify the address within 8000-9FF0 to which the\ndata will be copied. Only bits 12-4 are respected; others are ignored.\nThe four lower bits of this address will be ignored and treated as 0.")]),e._v(" "),a("h4",{attrs:{id:"ff55-hdma5-cgb-mode-only-new-dma-length-mode-start"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff55-hdma5-cgb-mode-only-new-dma-length-mode-start"}},[e._v("#")]),e._v(" FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start")]),e._v(" "),a("p",[e._v("These registers are used to initiate a DMA transfer from ROM or RAM to\nVRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0,\nthe lower four bits of the address are ignored (treated as zero). The\nDestination Start Address may be located at 8000-9FF0, the lower four\nbits of the address are ignored (treated as zero), the upper 3 bits are\nignored either (destination is always in VRAM).")]),e._v(" "),a("p",[e._v("Writing to this register starts the transfer, the lower 7 bits of which\nspecify the Transfer Length (divided by 10h, minus 1), ie. lengths of\n10h-800h bytes can be defined by the values 00h-7Fh. The upper bit\nindicates the Transfer Mode:")]),e._v(" "),a("h5",{attrs:{id:"bit7-0-general-purpose-dma"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bit7-0-general-purpose-dma"}},[e._v("#")]),e._v(" Bit7=0 - General Purpose DMA")]),e._v(" "),a("p",[e._v("When using this transfer method,\nall data is transferred at once. The execution of the program is halted\nuntil the transfer has completed. Note that the General Purpose DMA\nblindly attempts to copy the data, even if the LCD controller is\ncurrently accessing VRAM. So General Purpose DMA should be used only if\nthe Display is disabled, or during V-Blank, or (for rather short blocks)\nduring H-Blank. The execution of the program continues when the transfer\nhas been completed, and FF55 then contains a value of FFh.")]),e._v(" "),a("h5",{attrs:{id:"bit7-1-h-blank-dma"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bit7-1-h-blank-dma"}},[e._v("#")]),e._v(" Bit7=1 - H-Blank DMA")]),e._v(" "),a("p",[e._v("The H-Blank DMA transfers 10h bytes of\ndata during each H-Blank, ie. at LY=0-143, no data is transferred during\nV-Blank (LY=144-153), but the transfer will then continue at LY=00. The\nexecution of the program is halted during the separate transfers, but\nthe program execution continues during the 'spaces' between each data\nblock. Note that the program should not change the Destination VRAM bank\n(FF4F), or the Source ROM/RAM bank (in case data is transferred from\nbankable memory) until the transfer has completed! (The transfer should\nbe paused as described below while the banks are switched)")]),e._v(" "),a("p",[e._v('Reading from Register FF55 returns the remaining length (divided by 10h,\nminus 1), a value of 0FFh indicates that the transfer has completed. It\nis also possible to terminate an active H-Blank transfer by writing zero\nto Bit 7 of FF55. In that case reading from FF55 will return how many\n$10 "blocks" remained (minus 1) in the lower 7 bits, but Bit 7 will\nbe read as "1". Stopping the transfer doesn\'t set HDMA1-4 to $FF.')]),e._v(" "),a("h4",{attrs:{id:"precautions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#precautions"}},[e._v("#")]),e._v(" Precautions")]),e._v(" "),a("p",[e._v("H-Blank DMA should not be started (write to FF55) during a H-Blank\nperiod (STAT mode 0).")]),e._v(" "),a("p",[e._v("If the transfer's destination address overflows, the transfer stops\nprematurely. [Note : what's the state of the registers if this happens\n?]")]),e._v(" "),a("h4",{attrs:{id:"confirming-if-the-dma-transfer-is-active"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#confirming-if-the-dma-transfer-is-active"}},[e._v("#")]),e._v(" Confirming if the DMA Transfer is Active")]),e._v(" "),a("p",[e._v("Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is\nactive (1=Not Active, 0=Active). This works under any circumstances -\nafter completion of General Purpose, or H-Blank Transfer, and after\nmanually terminating a H-Blank Transfer.")]),e._v(" "),a("h4",{attrs:{id:"transfer-timings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transfer-timings"}},[e._v("#")]),e._v(" Transfer Timings")]),e._v(" "),a("p",[e._v("In both Normal Speed and Double Speed Mode it takes about 8 μs to\ntransfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode,\nand 16 'fast' tstates in Double Speed Mode. Older MBC controllers\n(like MBC1-4) and slower ROMs are not guaranteed to support General\nPurpose or H-Blank DMA, that's because there are always 2 bytes\ntransferred per microsecond (even if the itself program runs it Normal\nSpeed Mode).")]),e._v(" "),a("h2",{attrs:{id:"vram-tile-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vram-tile-data"}},[e._v("#")]),e._v(" VRAM Tile Data")]),e._v(" "),a("p",[e._v("Tile Data is stored in VRAM at addresses $8000-97FF; with one tile\nbeing 16 bytes large, this area defines data for 384 Tiles. In CGB Mode,\nthis is doubled (768 tiles) because of the two VRAM banks.")]),e._v(" "),a("p",[e._v("Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray\nshades. Tiles can be displayed as part of the Background/Window map,\nand/or as OAM tiles (foreground sprites). Note that foreground sprites\ndon't use color 0 - it's transparent instead.")]),e._v(" "),a("p",[e._v('There are three "blocks" of 128 tiles each:')]),e._v(" "),a("ul",[a("li",[e._v("Block 0 is $8000-87FF")]),e._v(" "),a("li",[e._v("Block 1 is $8800-8FFF")]),e._v(" "),a("li",[e._v("Block 2 is $9000-97FF")])]),e._v(" "),a("p",[e._v('Tiles are always indexed using a 8-bit integer, but the addressing\nmethod may differ. The "8000 method" uses $8000 as its base pointer\nand uses an unsigned addressing, meaning that tiles 0-127 are in block\n0, and tiles 128-255 are in block 1. The "8800 method" uses $9000 as\nits base pointer and uses a signed addressing. To put it differently,\n"8000 addressing" takes tiles 0-127 from block 0 and tiles 128-255\nfrom block 1, whereas "8800 addressing" takes tiles 0-127 from block 2\nand tiles 128-255 from block 1. (You can notice that block 1 is shared\nby both addressing methods)')]),e._v(" "),a("p",[e._v("Sprites always use 8000 addressing, but the BG and Window can use either\nmode, controlled by "),a("a",{attrs:{href:"#LCDC.4_-_BG_.26_Window_Tile_Data_Select",title:"wikilink"}},[e._v("LCDC bit\n4")]),e._v(".")]),e._v(" "),a("p",[e._v("Each Tile occupies 16 bytes, where each 2 bytes represent a line:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Byte 0-1  First Line (Upper 8 pixels)\nByte 2-3  Next Line\netc.`\n")])])]),a("p",[e._v("For each line, the first byte defines the least significant bits of the\ncolor numbers for each pixel, and the second byte defines the upper bits\nof the color numbers. In either case, Bit 7 is the leftmost pixel, and\nBit 0 the rightmost. For example : let's say you have $57 $36 (in\nthis order in memory). To obtain the color index for the leftmost pixel,\nyou take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For\nthe second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b =\n1 (remember to flip the order of the bits !). If you repeat the\noperation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3\n3 1.")]),e._v(" "),a("p",[e._v("A more visual explanation can be found\n"),a("a",{attrs:{href:"https://www.huderlem.com/demos/gameboy2bpp.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("So, each pixel is having a color number in range from 0-3. The color\nnumbers are translated into real colors (or gray shades) depending on\nthe current palettes. The palettes are defined through registers\n"),a("a",{attrs:{href:"#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only",title:"wikilink"}},[e._v("BGP")]),e._v(",\n"),a("a",{attrs:{href:"#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only",title:"wikilink"}},[e._v("OBP0")]),e._v("\nand\n"),a("a",{attrs:{href:"#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only",title:"wikilink"}},[e._v("OBP1")]),e._v("\n(Non CGB Mode), and\n"),a("a",{attrs:{href:"#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index",title:"wikilink"}},[e._v("BCPS/BGPI")]),e._v(",\n"),a("a",{attrs:{href:"#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data",title:"wikilink"}},[e._v("BCPD/BGPD")]),e._v(",\n"),a("a",{attrs:{href:"#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data",title:"wikilink"}},[e._v("OCPS/OBPI and\nOCPD/OBPD")]),e._v("\n(CGB Mode).")]),e._v(" "),a("h2",{attrs:{id:"vram-background-maps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vram-background-maps"}},[e._v("#")]),e._v(" VRAM Background Maps")]),e._v(" "),a("p",[e._v('The Game Boy contains two 32x32 tile background maps in VRAM at\naddresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to\ndisplay "normal" background, or "window" background.')]),e._v(" "),a("h4",{attrs:{id:"bg-map-tile-numbers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bg-map-tile-numbers"}},[e._v("#")]),e._v(" BG Map Tile Numbers")]),e._v(" "),a("p",[e._v("An area of VRAM known as Background Tile Map contains the numbers of\ntiles to be displayed. It is organized as 32 rows of 32 bytes each. Each\nbyte contains a number of a tile to be displayed.")]),e._v(" "),a("p",[e._v("Tile patterns are taken from the Tile Data Table using either of the two\naddressing modes (described "),a("a",{attrs:{href:"#VRAM_Tile_Data",title:"wikilink"}},[e._v("above")]),e._v("), which\ncan be selected via LCDC register.")]),e._v(" "),a("p",[e._v("As one background tile has a size of 8x8 pixels, the BG maps may hold a\npicture of 256x256 pixels, and an area of 160x144 pixels of this picture\ncan be displayed on the LCD screen.")]),e._v(" "),a("h4",{attrs:{id:"bg-map-attributes-cgb-mode-only"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bg-map-attributes-cgb-mode-only"}},[e._v("#")]),e._v(" BG Map Attributes (CGB Mode only)")]),e._v(" "),a("p",[e._v("In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1\n(each byte defines attributes for the corresponding tile-number map\nentry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at\n0:9800):")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Bit 0-2  Background Palette number  (BGP0-7)\nBit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)\nBit 4    Not used\nBit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)\nBit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)\nBit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)\n")])])]),a("p",[e._v("When Bit 7 is set, the corresponding BG tile will have priority above\nall OBJs (regardless of the priority bits in OAM memory). There's also\na Master Priority flag in LCDC register Bit 0 which overrides all other\npriority bits when cleared.")]),e._v(" "),a("p",[e._v("Note that, if the map entry at 0:9800 is tile $2A, the attribute at\n1:9800 doesn't define properties for ALL tiles $2A on-screen, but only\nthe one at 0:9800 !")]),e._v(" "),a("h4",{attrs:{id:"normal-background-bg"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#normal-background-bg"}},[e._v("#")]),e._v(" Normal Background (BG)")]),e._v(" "),a("p",[e._v("The SCY and SCX registers can be used to scroll the background, allowing\nto select the origin of the visible 160x144 pixel area within the total\n256x256 pixel background map. Background wraps around the screen (i.e.\nwhen part of it goes off the screen, it appears on the opposite side.)")]),e._v(" "),a("h4",{attrs:{id:"the-window"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-window"}},[e._v("#")]),e._v(" The Window")]),e._v(" "),a("p",[e._v('Besides background, there is also a "window" overlaying the\nbackground. The window is not scrollable, that is, it is always\ndisplayed starting from its left upper corner. The location of a window\non the screen can be adjusted via WX and WY registers. Screen\ncoordinates of the top left corner of a window are WX-7,WY. The tiles\nfor the window are stored in the Tile Data Table. Both the Background\nand the window share the same Tile Data Table.')]),e._v(" "),a("p",[e._v("Both background and window can be disabled or enabled separately via\nbits in the LCDC register.")]),e._v(" "),a("h2",{attrs:{id:"vram-banks-cgb-only"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vram-banks-cgb-only"}},[e._v("#")]),e._v(" VRAM Banks (CGB only)")]),e._v(" "),a("p",[e._v("The CGB has twice the VRAM of the DMG, but it is banked and either bank\nhas a different purpose.")]),e._v(" "),a("h4",{attrs:{id:"ff4f-vbk-cgb-mode-only-vram-bank-r-w"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ff4f-vbk-cgb-mode-only-vram-bank-r-w"}},[e._v("#")]),e._v(" FF4F - VBK - CGB Mode Only - VRAM Bank (R/W)")]),e._v(" "),a("p",[e._v("This register can be written to to change VRAM banks. Only bit 0\nmatters, all other bits are ignored.")]),e._v(" "),a("h4",{attrs:{id:"vram-bank-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vram-bank-1"}},[e._v("#")]),e._v(" VRAM bank 1")]),e._v(" "),a("p",[e._v("VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles\n(just like in bank 0), which can be accessed the same way as (and at the\nsame time as) bank 0 tiles. 9800-9FFF contains the attributes for the\ncorresponding Tile Maps.")]),e._v(" "),a("p",[e._v("Reading from this register will return the number of the currently\nloaded VRAM bank in bit 0, and all other bits will be set to 1.")]),e._v(" "),a("h2",{attrs:{id:"vram-sprite-attribute-table-oam"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vram-sprite-attribute-table-oam"}},[e._v("#")]),e._v(" VRAM Sprite Attribute Table (OAM)")]),e._v(" "),a("p",[e._v("Gameboy video controller can display up to 40 sprites either in 8x8 or\nin 8x16 pixels. Because of a limitation of hardware, only ten sprites\ncan be displayed per scan line. Sprite patterns have the same format as\nBG tiles, but they are taken from the Sprite Pattern Table located at\n$8000-8FFF and have unsigned numbering.")]),e._v(" "),a("p",[e._v("Sprite attributes reside in the Sprite Attribute Table (OAM - Object\nAttribute Memory) at $FE00-FE9F. Each of the 40 entries consists of\nfour bytes with the following meanings:")]),e._v(" "),a("h4",{attrs:{id:"byte0-y-position"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#byte0-y-position"}},[e._v("#")]),e._v(" Byte0 - Y Position")]),e._v(" "),a("p",[e._v("Specifies the sprites vertical position on the screen (minus 16). An\noff-screen value (for example, Y=0 or Y>=160) hides the sprite.")]),e._v(" "),a("h4",{attrs:{id:"byte1-x-position"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#byte1-x-position"}},[e._v("#")]),e._v(" Byte1 - X Position")]),e._v(" "),a("p",[e._v("Specifies the sprites horizontal position on the screen (minus 8). An\noff-screen value (X=0 or X>=168) hides the sprite, but the sprite still\naffects the priority ordering - a better way to hide a sprite is to set\nits Y-coordinate off-screen.")]),e._v(" "),a("h4",{attrs:{id:"byte2-tile-pattern-number"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#byte2-tile-pattern-number"}},[e._v("#")]),e._v(" Byte2 - Tile/Pattern Number")]),e._v(" "),a("p",[e._v('Specifies the sprites Tile Number (00-FF). This (unsigned) value selects\na tile from memory at 8000h-8FFFh. In CGB Mode this could be either in\nVRAM Bank 0 or 1, depending on Bit 3 of the following byte. In 8x16\nmode, the lower bit of the tile number is ignored. IE: the upper 8x8\ntile is "NN AND FEh", and the lower 8x8 tile is "NN OR 01h".')]),e._v(" "),a("h4",{attrs:{id:"byte3-attributes-flags"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#byte3-attributes-flags"}},[e._v("#")]),e._v(" Byte3 - Attributes/Flags:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)\n        (Used for both BG and Window. BG color 0 is always behind OBJ)\n Bit6   Y flip          (0=Normal, 1=Vertically mirrored)\n Bit5   X flip          (0=Normal, 1=Horizontally mirrored)\n Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)\n Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)\n Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)\n")])])]),a("h4",{attrs:{id:"sprite-priorities-and-conflicts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sprite-priorities-and-conflicts"}},[e._v("#")]),e._v(" Sprite Priorities and Conflicts")]),e._v(" "),a("p",[e._v("During each scanline's OAM scan, the LCD controller compares LY to each\nsprite's Y position to find the 10 sprites on that line that appear\nfirst in OAM ($FE00-$FE03 being the first). It discards the rest,\nallowing only 10 sprites to be displayed on any one line. When this\nlimit is exceeded, sprites appearing later in OAM won't be displayed.\nTo keep unused sprites from affecting onscreen sprites, set their Y\ncoordinate to Y = 0 or Y >= 160 (144 + 16) (Note : Y <= 8 also works\nif sprite size is set to 8x8). Just setting the X coordinate to X = 0 or\nX >= 168 (160 + 8) on a sprite will hide it, but it will still affect\nother sprites sharing the same lines.")]),e._v(" "),a("p",[e._v("If using "),a("a",{attrs:{href:"BGB",title:"wikilink"}},[e._v("BGB")]),e._v(", in the VRAM viewer - OAM tab, hover your\nmouse over the small screen to highlight the sprites on a line. Sprites\nhidden due to the limitation will be highlighted in red.")]),e._v(" "),a("p",[e._v("When these 10 sprites overlap, the highest priority one will appear\nabove all others, etc. (Thus, no Z-fighting.) In CGB mode, the first\nsprite in OAM ($FE00-$FE03) has the highest priority, and so on. In\nNon-CGB mode, the smaller the X coordinate, the higher the priority. The\ntie breaker (same X coordinates) is the same priority as in CGB mode.")]),e._v(" "),a("p",[e._v("The priority calculation between sprites disregards OBJ-to-BG Priority\n(attribute bit 7). Only the highest-priority nonzero sprite pixel at any\ngiven point is compared against the background. Thus if a sprite with a\nhigher priority (based on OAM index) but with OBJ-to-BG Priority turned\non overlaps a sprite with a lower priority and a nonzero background\npixel, the background pixel is displayed regardless of the\nlower-priority sprite's OBJ-to-BG Priority.")]),e._v(" "),a("h4",{attrs:{id:"writing-data-to-oam-memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#writing-data-to-oam-memory"}},[e._v("#")]),e._v(" Writing Data to OAM Memory")]),e._v(" "),a("p",[e._v("The recommended method is to write the data to normal RAM first, and to\ncopy that RAM to OAM by using the DMA transfer function, initiated\nthrough DMA register (FF46). Beside for that, it is also possible to\nwrite data directly to the OAM area by using normal LD commands, this\nworks only during the H-Blank and V-Blank periods. The current state of\nthe LCD controller can be read out from the STAT register (FF41).")]),e._v(" "),a("h2",{attrs:{id:"accessing-vram-and-oam"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#accessing-vram-and-oam"}},[e._v("#")]),e._v(" Accessing VRAM and OAM")]),e._v(" "),a("h4",{attrs:{id:"caution"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#caution"}},[e._v("#")]),e._v(" CAUTION")]),e._v(" "),a("p",[e._v("When the LCD Controller is drawing the screen it is directly reading\nfrom Video Memory (VRAM) and from the Sprite Attribute Table (OAM).\nDuring these periods the Gameboy CPU may not access the VRAM and OAM.\nThat means, any attempts to write to VRAM/OAM are ignored (the data\nremains unchanged). And any attempts to read from VRAM/OAM will return\nundefined data (typically a value of FFh).")]),e._v(" "),a("p",[e._v("For this reason the program should verify if VRAM/OAM is accessible\nbefore actually reading or writing to it. This is usually done by\nreading the Mode Bits from the STAT Register (FF41). When doing this (as\ndescribed in the examples below) you should take care that no interrupts\noccur between the wait loops and the following memory access - the\nmemory is guaranteed to be accessible only for a few cycles directly\nafter the wait loops have completed.")]),e._v(" "),a("h4",{attrs:{id:"vram-memory-at-8000h-9fffh-is-accessible-during-mode-0-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vram-memory-at-8000h-9fffh-is-accessible-during-mode-0-2"}},[e._v("#")]),e._v(" VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Mode 0 - H-Blank Period,\nMode 1 - V-Blank Period, and\nMode 2 - Searching OAM Period\n")])])]),a("p",[e._v("A typical procedure that waits for accessibility of VRAM would be:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ld   hl,0FF41h    ;-STAT Register\n@@wait:           ;\nbit  1,(hl)       ; Wait until Mode is 0 or 1\njr   nz,@@wait    ;\n")])])]),a("p",[e._v("Even if the procedure gets executed at the "),a("em",[e._v("end")]),e._v(" of Mode 0 or 1, it is\nstill proof to assume that VRAM can be accessed for a few more cycles\nbecause in either case the following period is Mode 2 which allows\naccess to VRAM either. However, be careful about STAT LCD interrupts or\nother interrupts that could cause the LCD to be back in mode 3 by the\ntime it returns. In CGB Mode an alternate method to write data to VRAM\nis to use the HDMA Function (FF51-FF55).")]),e._v(" "),a("p",[e._v("If you're not using LCD interrupts, another way to synchronize to the\nstart of mode 0 is to use "),a("code",[e._v("halt")]),e._v(" with IME turned off ("),a("code",[e._v("di")]),e._v("). This allows\nuse of the entire mode 0 on one line and mode 2 on the following line,\nwhich sum to 165 to 288 dots. For comparison, at single speed (4 dots\nper machine cycle), a "),a("a",{attrs:{href:"Popslide",title:"wikilink"}},[e._v("copy from stack")]),e._v(" that takes\n9 cycles per 2 bytes can push 8 bytes (half a tile) in 144 dots, which\nfits within the worst case timing for mode 0+2.")]),e._v(" "),a("h4",{attrs:{id:"oam-memory-at-fe00h-fe9fh-is-accessible-during-mode-0-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#oam-memory-at-fe00h-fe9fh-is-accessible-during-mode-0-1"}},[e._v("#")]),e._v(" OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Mode 0 - H-Blank Period\nMode 1 - V-Blank Period\n")])])]),a("p",[e._v("Aside from that, OAM can be accessed at any time by using the DMA\nFunction (FF46). When directly reading or writing to OAM, a typical\nprocedure that waits for accessibility of OAM Memory would be:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" ld   hl,0FF41h    ;-STAT Register\n@@wait1:           ;\n bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1\n jr   z,@@wait1    ;\n@@wait2:           ;\n bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-\n jr   nz,@@wait2   ;\n")])])]),a("p",[e._v("The two wait loops ensure that Mode 0 or 1 will last for a few clock\ncycles after completion of the procedure. In V-Blank period it might be\nrecommended to skip the whole procedure - and in most cases using the\nabove mentioned DMA function would be more recommended anyways.")]),e._v(" "),a("h4",{attrs:{id:"note"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#note"}},[e._v("#")]),e._v(" Note")]),e._v(" "),a("p",[e._v("When the display is disabled, both VRAM and OAM are accessible at any\ntime. The downside is that the screen is blank (white) during this\nperiod, so that disabling the display would be recommended only during\ninitialization.")])])}),[],!1,null,null,null);t.default=n.exports}}]);