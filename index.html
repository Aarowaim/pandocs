<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Pan Docs | Pan Docs</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/pandocs/assets/css/0.styles.d2a81c02.css" as="style"><link rel="preload" href="/pandocs/assets/js/app.4b9c9e14.js" as="script"><link rel="preload" href="/pandocs/assets/js/3.996332f8.js" as="script"><link rel="preload" href="/pandocs/assets/js/2.0dbba3d2.js" as="script"><link rel="preload" href="/pandocs/assets/js/7.6c343c2b.js" as="script"><link rel="prefetch" href="/pandocs/assets/js/4.7a4cca3d.js"><link rel="prefetch" href="/pandocs/assets/js/5.882fbb48.js"><link rel="prefetch" href="/pandocs/assets/js/6.f4344271.js"><link rel="prefetch" href="/pandocs/assets/js/8.8c4ddf07.js">
    <link rel="stylesheet" href="/pandocs/assets/css/0.styles.d2a81c02.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/pandocs/" class="home-link router-link-exact-active router-link-active"><!----> <span class="site-name">Pan Docs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/gbdev/pandocs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Contribute
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/gbdev/pandocs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Contribute
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="pan-docs"><a href="#pan-docs" class="header-anchor">#</a> Pan Docs</h1> <p>The single, most comprehensive technical reference to Game Boy available to the public.</p> <h3 id="table-of-contents"><a href="#table-of-contents" class="header-anchor">#</a> Table of Contents</h3> <ul><li>Overview
<ul><li><a href="#about-the-pan-docs">About the Pan Docs</a></li> <li><a href="#authors">Authors</a></li> <li><a href="#specifications">Specifications</a></li> <li><a href="#memory-map">Memory Map</a></li></ul></li> <li>I/O Ports
<ul><li><a href="#video-display">Video Display</a></li> <li><a href="#sound-controller">Sound Controller</a></li> <li><a href="#joypad-input">Joypad Input</a></li> <li><a href="#serial-data-transfer">Serial Data Transfer (Link Cable)</a></li> <li><a href="#timer-and-divider-registers">Timer and Divider Registers</a></li> <li><a href="#interrupts">Interrupts</a></li> <li>CGB Registers</li> <li>SGB Functions</li></ul></li> <li>CPU Specifications
<ul><li>Registers and Flags</li> <li>Instruction Set</li> <li>Comparision with Z80</li></ul></li> <li>Cartridges
<ul><li>Cartridge header</li> <li><a href="#mbc1">MBC1</a></li> <li>MBC2</li> <li>MBC3</li> <li>MBC5</li> <li>MBC6</li> <li>MBC7</li> <li>HuC1</li></ul></li> <li>Accessories
<ul><li>Game Boy Printer</li> <li>Game Boy Camera</li> <li>Gamegenie/Shark Cheats</li></ul></li> <li>Other
<ul><li><a href="#power-up-sequence">Power Up Sequence</a></li> <li>Reducing Power Consumption</li> <li>Sprite RAM Bug</li> <li>External Connectors</li></ul></li> <li><a href="#references">References</a></li></ul> <hr> <h1 id="about-the-pan-docs"><a href="#about-the-pan-docs" class="header-anchor">#</a> About the Pan Docs</h1> <p>This is a new, experimental version of Pan Docs, mantained in the Markdown format.</p> <p>To learn more about the history and the mission of the project, check the <a href="https://github.com/gbdev/pandocs#history" target="_blank" rel="noopener noreferrer">README<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <h2 id="authors"><a href="#authors" class="header-anchor">#</a> Authors</h2> <p>This document is the product of 25 years of community effort: it's hard to keep track of every contribution. If we missed something, contact us.</p> <p>Non-exhaustive, list of content contributors:</p> <p><em>Pan of ATX, Marat Fayzullin, Felber Pascal, Robson Paul, Korth Martin.</em></p> <p><em>Antonio Niño Díaz, Antonio Vivace, Beannaich, Elizafox, endrift, exezin, Furrtek, Gekkio, ISSOtm, Jeff Frohwein, John Harrison, kOOPa, LIJI32, Mantidactyle, mattcurrie, nitro2k01, Pascal Felber, pinobatch, T4g1, TechFalcon</em></p> <h1 id="specifications"><a href="#specifications" class="header-anchor">#</a> Specifications</h1> <ul><li>CPU - 8-bit Sharp LR25902 (similar to the Z80 processor)</li> <li>Clock Speed - 4.194304MHz (4.295454MHz for SGB, max. 8.4MHz for CGB)</li> <li>Work RAM - 8K Byte (32K Byte for CGB)</li> <li>Video RAM - 8K Byte (16K Byte for CGB)</li> <li>Screen Size - 2.6&quot;</li> <li>Resolution - 160x144 (20x18 tiles)</li> <li>Max sprites - Max 40 per screen, 10 per line</li> <li>Sprite sizes - 8x8 or 8x16 pixels</li> <li>Palettes - 1x4 BG, 2x3 OBJ (for CGB: 8x4 BG, 8x3 OBJ)</li> <li>Colors - 4 grayshades (32768 colors for CGB)</li> <li>Horiz Sync - 9198 KHz (9420 KHz for SGB)</li> <li>Vert Sync - 59.73 Hz (61.17 Hz for SGB)</li> <li>Sound - 4 channels with stereo sound</li> <li>Power - DC6V 0.7W (DC3V 0.7W for GB Pocket, DC3V 0.6W for CGB)</li></ul> <h1 id="memory-map"><a href="#memory-map" class="header-anchor">#</a> Memory Map</h1> <p>The Game Boy has a 16bit address bus, that is used to address ROM, RAM and I/O</p> <h2 id="general-memory-map"><a href="#general-memory-map" class="header-anchor">#</a> General Memory Map</h2> <table><thead><tr><th><strong>Start</strong></th> <th><strong>End</strong></th> <th><strong>Description</strong></th> <th><strong>Notes</strong></th></tr></thead> <tbody><tr><td>0000</td> <td>3FFF</td> <td>16KB ROM bank 00</td> <td>From cartridge, usually a fixed bank</td></tr> <tr><td>4000</td> <td>7FFF</td> <td>16KB ROM Bank 01~NN</td> <td>From cartridge, switchable bank via <a href="Memory_Bank_Controllers" title="wikilink">MB</a> (if any)</td></tr> <tr><td>8000</td> <td>9FFF</td> <td>8KB Video RAM (VRAM)</td> <td>Only bank 0 in Non-CGB mode Switchable bank 0/1 in CGB mode</td></tr> <tr><td>A000</td> <td>BFFF</td> <td>8KB External RAM</td> <td>In cartridge, switchable bank if any</td></tr> <tr><td>C000</td> <td>CFFF</td> <td>4KB Work RAM (WRAM) bank 0</td> <td></td></tr> <tr><td>D000</td> <td>DFFF</td> <td>4KB Work RAM (WRAM) bank 1~N</td> <td>Only bank 1 in Non-CGB mode Switchable bank 1~7 in CGB mode</td></tr> <tr><td>E000</td> <td>FDFF</td> <td>Mirror of C000~DDFF (ECHO RAM)</td> <td>Typically not used</td></tr> <tr><td>FE00</td> <td>FE9F</td> <td>Sprite attribute table (<a href="Video_Display#VRAM_Sprite_Attribute_Table_.28OAM.29" title="wikilink">OAM</a>)</td> <td></td></tr> <tr><td>FEA0</td> <td>FEFF</td> <td>Not Usable</td> <td></td></tr> <tr><td>FF00</td> <td>FF7F</td> <td>I/O Registers</td> <td></td></tr> <tr><td>FF80</td> <td>FFFE</td> <td>High RAM (HRAM)</td> <td></td></tr> <tr><td>FFFF</td> <td>FFFF</td> <td><a href="Interrupts" title="wikilink">Interrupts</a> Enable Register (IE)</td> <td></td></tr></tbody></table> <h2 id="jump-vectors-in-first-rom-bank"><a href="#jump-vectors-in-first-rom-bank" class="header-anchor">#</a> Jump Vectors in first ROM bank</h2> <p>The following addresses are supposed to be used as jump vectors:</p> <ul><li>RST commands: 0000, 0008,0010, 0018, 0020, 0028, 0030, 0038</li> <li>Interrupts: 0040, 0048, 0050, 0058, 0060</li></ul> <p>However, the memory may be used for any other purpose in case that your
program doesn't use any (or only some) RST commands or interrupts. RST
commands are 1-byte opcodes that work similar to CALL opcodes, except
that the destination address is fixed. Since they are only 1 byte large,
they are also slightly faster.</p> <h2 id="cartridge-header-in-first-rom-bank"><a href="#cartridge-header-in-first-rom-bank" class="header-anchor">#</a> Cartridge Header in first ROM bank</h2> <p>The memory at 0100-014F contains the <a href="The_Cartridge_Header" title="wikilink">cartridge
header</a>. This area contains information
about the program, its entry point, checksums, information about the
used MBC chip, the ROM and RAM sizes, etc. Most of the bytes in this
area are required to be specified correctly. For more information read
the chapter about The Cartridge Header.</p> <h2 id="external-memory-and-hardware"><a href="#external-memory-and-hardware" class="header-anchor">#</a> External Memory and Hardware</h2> <p>The areas from 0000-7FFF and A000-BFFF may be used to connect external
hardware. The first area is typically used to address ROM (read only, of
course), cartridges with <a href="Memory_Bank_Controllers" title="wikilink">Memory Bank Controllers
(MBCs)</a> are additionally using this
area to output data (write only) to the MBC chip. The second area is
often used to address external RAM, or to address other external
hardware (<a href="RTC" title="wikilink">Real Time Clock</a>, etc). External memory is
often battery buffered, and may hold saved game positions and high score
tables (etc.) even when the Game Boy is turned off, or when the
cartridge is removed. For specific information read the chapter about
Memory Bank Controllers.</p> <h2 id="echo-ram"><a href="#echo-ram" class="header-anchor">#</a> Echo RAM</h2> <p>The memory range E000-FDFF is a mirror (or &quot;echo&quot;) of WRAM, both for
reading and writing. For example, writing to $E123 will modify both
$C123 and $E123. It is recommended to avoid using this memory range
anyways. This memory range's behavior has been confirmed on all grey
GBs as well as on CGB and GBA. Some emulators (such as VisualBoyAdvance
&lt;1.8) don't emulate Echo RAM. It is possible to check if Echo RAM is
properly emulated by writing to WRAM (avoid values 00 and FF) and
checking if said value is mirrored in Echo RAM.</p> <h2 id="fea0-feff-range"><a href="#fea0-feff-range" class="header-anchor">#</a> FEA0-FEFF range</h2> <p>This range is very poorly documented. It doesn't even have a name !
From my experience, this stays 00 on DMG, and alternates between 00 and
seemingly random values on CGB.</p> <h1 id="video-display"><a href="#video-display" class="header-anchor">#</a> Video Display</h1> <h2 id="lcd-control-register"><a href="#lcd-control-register" class="header-anchor">#</a> LCD Control Register</h2> <p><strong>LCDC</strong> is the main <strong>LCD C</strong>ontrol register. Its bits toggle what
elements are displayed on the screen, and how.</p> <div class="language- extra-class"><pre class="language-text"><code>Bit 7 - LCD Display Enable             (0=Off, 1=On)
Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
Bit 5 - Window Display Enable          (0=Off, 1=On)
Bit 4 - BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
Bit 0 - BG/Window Display/Priority     (0=Off, 1=On)
</code></pre></div><h3 id="lcdc-7-lcd-display-enable"><a href="#lcdc-7-lcd-display-enable" class="header-anchor">#</a> LCDC.7 - LCD Display Enable</h3> <p>This bit controls whether the LCD is on and the PPU is active. Setting
it to 0 turns both off, which grants immediate and full access to VRAM,
OAM, etc.</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>Stopping LCD operation (Bit 7 from 1 to 0) may be performed
during <a href="VBlank" title="wikilink">VBlank</a> ONLY, disabling the display outside
of the V-Blank period may damage the hardware by burning in a black
horizontal line similar to that which appears when the GB is turned off.
This appears to be a serious issue, Nintendo is reported to reject any
games that do not follow this rule.</p></div> <p>When the display is disabled the screen is blank, which on DMG is
displayed as a white &quot;whiter&quot; than color #0.</p> <p>On SGB, the screen doesn't turn white, it appears that the previous
picture sticks to the screen. (TODO: research this more.)</p> <p>When re-enabling the LCD, the PPU will immediately start drawing again,
but the screen will stay blank during the first frame.</p> <h3 id="lcdc-6-window-tile-map-display-select"><a href="#lcdc-6-window-tile-map-display-select" class="header-anchor">#</a> LCDC.6 - Window Tile Map Display Select</h3> <p>This bit controls which background map the Window uses for rendering.
When it's reset, the $9800 tilemap is used, otherwise it's the $9C00
one.</p> <h3 id="lcdc-5-window-display-enable"><a href="#lcdc-5-window-display-enable" class="header-anchor">#</a> LCDC.5 - Window Display Enable</h3> <p>This bit controls whether the window shall be displayed or not. (TODO :
what happens when toggling this mid-scanline ?) This bit is overridden
on DMG by <a href="#LCDC.0_-_BG.2FWindow_Display.2FPriority" title="wikilink">bit 0</a>
if that bit is reset.</p> <p>Note that on CGB models, setting this bit to 0 then back to 1 mid-frame
may cause the second write to be ignored. (TODO : test this.)</p> <h3 id="lcdc-4-bg-window-tile-data-select"><a href="#lcdc-4-bg-window-tile-data-select" class="header-anchor">#</a> LCDC.4 - BG &amp; Window Tile Data Select</h3> <p>This bit controls which <a href="Video_Display#VRAM_Tile_Data" title="wikilink">addressing
mode</a> the BG and Window use to
pick tiles.</p> <p>Sprites aren't affected by this, and will always use $8000 addressing
mode.</p> <h3 id="lcdc-3-bg-tile-map-display-select"><a href="#lcdc-3-bg-tile-map-display-select" class="header-anchor">#</a> LCDC.3 - BG Tile Map Display Select</h3> <p>This bit works similarly to LCDC-6: if the bit is
reset, the BG uses tilemap $9800, otherwise tilemap $9C00.</p> <h3 id="lcdc-2-obj-size"><a href="#lcdc-2-obj-size" class="header-anchor">#</a> LCDC.2 - OBJ Size</h3> <p>This bit controls the sprite size (1 tile or 2 stacked vertically).</p> <p>Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot;
of the sprites intended for 8x8 could &quot;leak&quot; into the 8x16 zone and
cause artifacts.</p> <h3 id="lcdc-1-obj-display-enable"><a href="#lcdc-1-obj-display-enable" class="header-anchor">#</a> LCDC.1 - OBJ Display Enable</h3> <p>This bit toggles whether sprites are displayed or not.</p> <p>This can be toggled mid-frame, for example to avoid sprites being
displayed on top of a status bar or text box.</p> <p>(Note: toggling mid-scanline might have funky results on DMG?
Investigation needed.)</p> <h3 id="lcdc-0-bg-window-display-priority"><a href="#lcdc-0-bg-window-display-priority" class="header-anchor">#</a> LCDC.0 - BG/Window Display/Priority</h3> <p>LCDC.0 has different meanings depending on Game Boy type and Mode:</p> <h4 id="monochrome-gameboy-sgb-and-cgb-in-non-cgb-mode-bg-display"><a href="#monochrome-gameboy-sgb-and-cgb-in-non-cgb-mode-bg-display" class="header-anchor">#</a> Monochrome Gameboy, SGB and CGB in Non-CGB Mode: BG Display</h4> <p>When Bit 0 is cleared, both background and window become blank (white),
and the <a href="#LCDC.5_-_Window_Display_Enable" title="wikilink">Window Display Bit</a>
is ignored in that case. Only Sprites may still be displayed (if enabled
in Bit 1).</p> <h4 id="cgb-in-cgb-mode-bg-and-window-master-priority"><a href="#cgb-in-cgb-mode-bg-and-window-master-priority" class="header-anchor">#</a> CGB in CGB Mode: BG and Window Master Priority</h4> <p>When Bit 0 is cleared, the background and window lose their priority -
the sprites will be always displayed on top of background and window,
independently of the priority flags in OAM and BG Map attributes.</p> <h3 id="using-lcdc"><a href="#using-lcdc" class="header-anchor">#</a> Using LCDC</h3> <p>LCDC is a powerful tool: each bit controls a lot of behavior, and can be
modified at any time during the frame.</p> <p>One of the important aspects of LCDC is that unlike VRAM, the PPU never
locks it. It's thus possible to modify it mid-scanline!</p> <h3 id="faux-layer-textbox-status-bar"><a href="#faux-layer-textbox-status-bar" class="header-anchor">#</a> Faux-layer textbox/status bar</h3> <p>A problem often seen especially in NES games is sprites rendering on top
of the textbox/status bar. It's possible to prevent this using LCDC if
the textbox/status bar is &quot;alone&quot; on its scanlines:</p> <ul><li>Set LCDC.1 to 1 for gameplay scanlines</li> <li>Set LCDC.1 to 0 for textbox/status bar scanlines</li></ul> <p>Usually, these bars are either at the top or bottom of the screen, so
the bit can be set by the <a href="VBlank_handler" title="wikilink">VBlank handler</a></p> <h2 id="lcd-status-register"><a href="#lcd-status-register" class="header-anchor">#</a> LCD Status Register</h2> <h4 id="ff41-stat-lcdc-status-r-w"><a href="#ff41-stat-lcdc-status-r-w" class="header-anchor">#</a> FF41 - STAT - LCDC Status (R/W)</h4> <div class="language- extra-class"><pre class="language-text"><code>Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
Bit 2 - Coincidence Flag  (0:LYC&lt;&gt;LY, 1:LYC=LY) (Read Only)
Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
          0: During H-Blank
          1: During V-Blank
          2: During Searching OAM
          3: During Transferring Data to LCD Driver
</code></pre></div><p>The two lower STAT bits show the current status of the LCD controller.</p> <p>The LCD controller operates on a 2^22^ Hz = 4.194 MHz dot clock. An
entire frame is 154 scanlines, 70224 dots, or 16.74 ms. On scanlines 0
through 143, the LCD controller cycles through modes 2, 3, and 0 once
every 456 dots. Scanlines 144 through 153 are mode 1.</p> <p>The following are typical when the display is enabled:</p> <div class="language- extra-class"><pre class="language-text"><code>Mode 2  2_____2_____2_____2_____2_____2___________________2____
Mode 3  _33____33____33____33____33____33__________________3___
Mode 0  ___000___000___000___000___000___000________________000
Mode 1  ____________________________________11111111111111_____
</code></pre></div><p>When the LCD controller is reading a particular part of video memory,
that memory is inaccessible to the CPU.</p> <ul><li>During modes 2 and 3, the CPU cannot access OAM (FE00h-FE9Fh).</li> <li>During mode 3, the CPU cannot access VRAM or CGB Palette Data
(FF69,FF6B).</li></ul> <table><thead><tr><th>Mode</th> <th>Action</th> <th>Duration</th> <th>Accessible video memory</th></tr></thead> <tbody><tr><td>2</td> <td>Scanning OAM for (X, Y) coordinates of sprites that overlap this line</td> <td>80 dots (19 us)</td> <td>VRAM, CGB palettes</td></tr> <tr><td>3</td> <td>Reading OAM and VRAM to generate the picture</td> <td>168 to 291 cycles (40 to 60 us) depending on sprite count</td> <td>None</td></tr> <tr><td>0</td> <td>Horizontal blanking</td> <td>85 to 208 dots (20 to 49 us) depending on previous mode 3 duration</td> <td>VRAM, OAM, CGB palettes</td></tr> <tr><td>1</td> <td>Vertical blanking</td> <td>4560 dots (1087 us, 10 scanlines)</td> <td>VRAM, OAM, CGB palettes</td></tr></tbody></table> <p>: Properties of STAT modes</p> <p>Unlike most game consoles, the Game Boy can pause the dot clock briefly,
adding dots to mode 3's duration. It routinely takes a 6 to 11 dot
break to fetch sprite patterns between background tile pattern fetches.
On DMG and GBC in DMG mode, mid-scanline writes to <code>BGP</code> allow observing
this behavior, as a sprite delay shifts the effect of a write to the
left by that many dots.</p> <p>Three things are known to pause the dot clock:</p> <p>Background scrolling
:   If <code>SCX mod 8</code> is not zero at the start of the scanline, rendering
is paused for that many dots while the shifter discards that many
pixels from the leftmost tile.</p> <p>Window
:   An active window pauses for at least 6 dots, as the background
fetching mechanism starts over at the left side of the window.</p> <p>Sprites
:   Each sprite usually pauses for <code>11 - min(5, (x + SCX) mod 8)</code> dots.
Because sprite fetch waits for background fetch to finish, a
sprite's cost depends on its position relative to the left side of
the background tile under it. It's greater if a sprite is directly
aligned over the background tile, less if the sprite is to the
right. If the sprite's left side is over the window, use <code>255 - WX</code>
for <code>SCX</code> in this formula.</p> <p><strong>Not fully understood:</strong> The exact pause duration for window start is
not confirmed; it may have the same background fetch finish delay as a
sprite. If two sprites' left sides are over the same background or
window tile, the second may pause for fewer dots.</p> <p>A hardware quirk in the monochrome Game Boy makes the LCD interrupt
sometimes trigger when writing to STAT (including writing $00) during
OAM scan, H-Blank, V-Blank, or LY=LYC. It behaves as if $FF were
written for one cycle, and then the written value were written the next
cycle. Because the GBC in DMG mode does not have this quirk, two games
that depend on this quirk (Ocean's <em>Road Rash</em> and Vic Tokai's <em>Xerd
no Densetsu</em>) will not run on a GBC.</p> <h2 id="lcd-interrupts"><a href="#lcd-interrupts" class="header-anchor">#</a> LCD Interrupts</h2> <h4 id="int-40-v-blank-interrupt"><a href="#int-40-v-blank-interrupt" class="header-anchor">#</a> INT 40 - V-Blank Interrupt</h4> <p>The V-Blank interrupt occurs ca. 59.7 times a second on a handheld Game
Boy (DMG or CGB) or Game Boy Player and ca. 61.1 times a second on a
Super Game Boy (SGB). This interrupt occurs at the beginning of the
V-Blank period (LY=144). During this period video hardware is not using
VRAM so it may be freely accessed. This period lasts approximately 1.1
milliseconds.</p> <h4 id="int-48-lcdc-status-interrupt"><a href="#int-48-lcdc-status-interrupt" class="header-anchor">#</a> INT 48 - LCDC Status Interrupt</h4> <p>There are various reasons for this interrupt to occur as described by
the STAT register ($FF40). One very popular reason is to indicate to
the user when the video hardware is about to redraw a given LCD line.
This can be useful for dynamically controlling the SCX/SCY registers
($FF43/$FF42) to perform special video effects.</p> <p>Example application : set LYC to WY, enable LY=LYC interrupt, and have
the handler disable sprites. This can be used if you use the window for
a text box (at the bottom of the screen), and you want sprites to be
hidden by the text box.</p> <p>The interrupt is triggered when transitioning from &quot;No conditions met&quot;
to &quot;Any condition met&quot;, which can cause the interrupt to not fire.
Example : the Mode 0 and LY=LYC interrupts are enabled ; since the
latter triggers during Mode 2 (right after Mode 0), the interrupt will
trigger for Mode 0 but fail to for LY=LYC.</p> <h2 id="lcd-position-and-scrolling"><a href="#lcd-position-and-scrolling" class="header-anchor">#</a> LCD Position and Scrolling</h2> <p>These registers can be accessed even during Mode 3, but they have no
effect until the end of the current scanline.</p> <h4 id="ff42-scy-scroll-y-r-w-ff43-scx-scroll-x-r-w"><a href="#ff42-scy-scroll-y-r-w-ff43-scx-scroll-x-r-w" class="header-anchor">#</a> FF42 - SCY - Scroll Y (R/W), FF43 - SCX - Scroll X (R/W)</h4> <p>Specifies the position in the 256x256 pixels BG map (32x32 tiles) which
is to be displayed at the upper/left LCD display position. Values in
range from 0-255 may be used for X/Y each, the video controller
automatically wraps back to the upper (left) position in BG map when
drawing exceeds the lower (right) border of the BG map area.</p> <h4 id="ff44-ly-lcdc-y-coordinate-r"><a href="#ff44-ly-lcdc-y-coordinate-r" class="header-anchor">#</a> FF44 - LY - LCDC Y-Coordinate (R)</h4> <p>The LY indicates the vertical line to which the present data is
transferred to the LCD Driver. The LY can take on any value between 0
through 153. The values between 144 and 153 indicate the V-Blank period.</p> <h4 id="ff45-lyc-ly-compare-r-w"><a href="#ff45-lyc-ly-compare-r-w" class="header-anchor">#</a> FF45 - LYC - LY Compare (R/W)</h4> <p>The Game Boy permanently compares the value of the LYC and LY registers.
When both values are identical, the coincident bit in the STAT register
becomes set, and (if enabled) a STAT interrupt is requested.</p> <h4 id="ff4a-wy-window-y-position-r-w-ff4b-wx-window-x-position-minus-7-r-w"><a href="#ff4a-wy-window-y-position-r-w-ff4b-wx-window-x-position-minus-7-r-w" class="header-anchor">#</a> FF4A - WY - Window Y Position (R/W), FF4B - WX - Window X Position minus 7 (R/W)</h4> <p>Specifies the upper/left positions of the Window area. (The window is an
alternate background area which can be displayed above of the normal
background. OBJs (sprites) may be still displayed above or behind the
window, just as for normal BG.)</p> <p>The window becomes visible (if enabled) when positions are set in range
WX=0..166, WY=0..143. A position of WX=7, WY=0 locates the window at
upper left, it is then completely covering normal background.</p> <p>WX values 0-6 and 166 are unreliable due to hardware bugs. If WX is set
to 0, the window will &quot;stutter&quot; horizontally when SCX changes.
(Depending on SCX modulo 8, behavior is a little complicated so you
should try it yourself.)</p> <h2 id="lcd-monochrome-palettes"><a href="#lcd-monochrome-palettes" class="header-anchor">#</a> LCD Monochrome Palettes</h2> <h4 id="ff47-bgp-bg-palette-data-r-w-non-cgb-mode-only"><a href="#ff47-bgp-bg-palette-data-r-w-non-cgb-mode-only" class="header-anchor">#</a> FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only</h4> <p>This register assigns gray shades to the color numbers of the BG and
Window tiles.</p> <div class="language- extra-class"><pre class="language-text"><code>Bit 7-6 - Shade for Color Number 3
Bit 5-4 - Shade for Color Number 2
Bit 3-2 - Shade for Color Number 1
Bit 1-0 - Shade for Color Number 0
</code></pre></div><p>The four possible gray shades are:</p> <div class="language- extra-class"><pre class="language-text"><code>0  White
1  Light gray
2  Dark gray
3  Black
</code></pre></div><p>In CGB Mode the Color Palettes are taken from CGB Palette Memory
instead.</p> <h4 id="ff48-obp0-object-palette-0-data-r-w-non-cgb-mode-only"><a href="#ff48-obp0-object-palette-0-data-r-w-non-cgb-mode-only" class="header-anchor">#</a> FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only</h4> <p>This register assigns gray shades for sprite palette 0. It works exactly
as BGP (FF47), except that the lower two bits aren't used because
sprite data 00 is transparent.</p> <h4 id="ff49-obp1-object-palette-1-data-r-w-non-cgb-mode-only"><a href="#ff49-obp1-object-palette-1-data-r-w-non-cgb-mode-only" class="header-anchor">#</a> FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only</h4> <p>This register assigns gray shades for sprite palette 1. It works exactly
as BGP (FF47), except that the lower two bits aren't used because
sprite data 00 is transparent.</p> <h2 id="lcd-color-palettes-cgb-only"><a href="#lcd-color-palettes-cgb-only" class="header-anchor">#</a> LCD Color Palettes (CGB only)</h2> <h4 id="ff68-bcps-bgpi-cgb-mode-only-background-palette-index"><a href="#ff68-bcps-bgpi-cgb-mode-only-background-palette-index" class="header-anchor">#</a> FF68 - BCPS/BGPI - CGB Mode Only - Background Palette Index</h4> <p>This register is used to address a byte in the CGBs Background Palette
Memory. Each two byte in that memory define a color value. The first 8
bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.</p> <div class="language- extra-class"><pre class="language-text"><code>Bit 0-5   Index (00-3F)
Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)
</code></pre></div><p>Data can be read/written to/from the specified index address through
Register FF69. When the Auto Increment bit is set then the index is
automatically incremented after each <strong>write</strong> to FF69. Auto Increment has
no effect when <strong>reading</strong> from FF69, so the index must be manually
incremented in that case. Writing to FF69 during rendering still causes
auto-increment to occur.</p> <p>Unlike the following, this register can be accessed outside V-Blank and
H-Blank.</p> <h4 id="ff69-bcpd-bgpd-cgb-mode-only-background-palette-data"><a href="#ff69-bcpd-bgpd-cgb-mode-only-background-palette-data" class="header-anchor">#</a> FF69 - BCPD/BGPD - CGB Mode Only - Background Palette Data</h4> <p>This register allows to read/write data to the CGBs Background Palette
Memory, addressed through Register FF68. Each color is defined by two
bytes (Bit 0-7 in first byte).</p> <div class="language- extra-class"><pre class="language-text"><code>Bit 0-4   Red Intensity   (00-1F)
Bit 5-9   Green Intensity (00-1F)
Bit 10-14 Blue Intensity  (00-1F)
</code></pre></div><p>Much like VRAM, data in Palette Memory cannot be read/written during the
time when the LCD Controller is reading from it. (That is when the STAT
register indicates Mode 3). Note: All background colors are initialized
as white by the boot ROM, but it's a good idea to initialize at least
one color yourself (for example if you include a soft-reset mechanic).</p> <h4 id="ff6a-ocps-obpi-cgb-mode-only-sprite-palette-index-ff6b-ocpd-obpd-cgb-mode-only-sprite-palette-data"><a href="#ff6a-ocps-obpi-cgb-mode-only-sprite-palette-index-ff6b-ocpd-obpd-cgb-mode-only-sprite-palette-data" class="header-anchor">#</a> FF6A - OCPS/OBPI - CGB Mode Only - Sprite Palette Index, FF6B - OCPD/OBPD - CGB Mode Only - Sprite Palette Data</h4> <p>These registers are used to initialize the Sprite Palettes OBP0-7,
identically as described above for Background Palettes. Note that four
colors may be defined for each OBP Palettes - but only Color 1-3 of each
Sprite Palette can be displayed, Color 0 is always transparent, and can
be initialized to a don't care value or plain never initialized.</p> <p>Note: All sprite colors are left uninitialized by the boot ROM, and are
somewhat random.</p> <h4 id="rgb-translation-by-cgbs"><a href="#rgb-translation-by-cgbs" class="header-anchor">#</a> RGB Translation by CGBs</h4> <p><img src="VGA_versus_CGB.png" alt="sRGB versus CGB colormixing" title="fig:sRGB versus CGB color mixing">{width=&quot;150&quot;}
When developing graphics on PCs, note that the RGB values will have
different appearance on CGB displays as on VGA/HDMI monitors calibrated
to sRGB color. Because the GBC is not lit, the highest intensity will
produce Light Gray color rather than White. The intensities are not
linear; the values 10h-1Fh will all appear very bright, while medium and
darker colors are ranged at 00h-0Fh.</p> <p>The CGB display's pigments aren't perfectly saturated. This means the
colors mix quite oddly; increasing intensity of only one R,G,B color
will also influence the other two R,G,B colors. For example, a color
setting of 03EFh (Blue=0, Green=1Fh, Red=0Fh) will appear as Neon Green
on VGA displays, but on the CGB it'll produce a decently washed out
Yellow. See image on the right.</p> <h4 id="rgb-translation-by-gbas"><a href="#rgb-translation-by-gbas" class="header-anchor">#</a> RGB Translation by GBAs</h4> <p>Even though GBA is described to be compatible to CGB games, most CGB
games are completely unplayable on older GBAs because most colors are
invisible (black). Of course, colors such like Black and White will
appear the same on both CGB and GBA, but medium intensities are arranged
completely different. Intensities in range 00h..07h are invisible/black
(unless eventually under best sunlight circumstances, and when gazing at
the screen under obscure viewing angles), unfortunately, these
intensities are regularly used by most existing CGB games for medium and
darker colors.</p> <p>Newer CGB games may avoid this effect by changing palette data when
detecting GBA hardware (<a href="CGB_Registers#Detecting_CGB_.28and_GBA.29_functions" title="wikilink">see
how</a>).
Based on measurement of GBC and GBA palettes using the <a href="https://github.com/pinobatch/240p-test-mini/tree/master/gameboy" target="_blank" rel="noopener noreferrer">144p Test
Suite<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ROM, a fairly close approximation is GBA = GBC * 3/4 + 8h for
each R,G,B intensity. The result isn't quite perfect, and it may turn
out that the color mixing is different also; anyways, it'd be still
ways better than no conversion.</p> <p>This problem with low brightness levels does not affect later GBA SP
units and Game Boy Player. Thus ideally, the player should have control
of this brightness correction.</p> <h2 id="lcd-oam-dma-transfers"><a href="#lcd-oam-dma-transfers" class="header-anchor">#</a> LCD OAM DMA Transfers</h2> <h4 id="ff46-dma-dma-transfer-and-start-address-r-w"><a href="#ff46-dma-dma-transfer-and-start-address-r-w" class="header-anchor">#</a> FF46 - DMA - DMA Transfer and Start Address (R/W)</h4> <p>Writing to this register launches a DMA transfer from ROM or RAM to OAM
memory (sprite attribute table). The written value specifies the
transfer source address divided by 100h, ie. source &amp; destination are:</p> <div class="language- extra-class"><pre class="language-text"><code>Source:      XX00-XX9F   ;XX in range from 00-F1h
Destination: FE00-FE9F
</code></pre></div><p>The transfer takes 160 machine cycles: 152 microseconds in normal speed
or 76 microseconds in CGB Double Speed Mode. On DMG, during this time,
the CPU can access only HRAM (memory at FF80-FFFE); on CGB, the bus used
by the source area cannot be used (this isn't understood well at the
moment, it's recommended to assume same behavior as DMG). For this
reason, the programmer must copy a short procedure into HRAM, and use
this procedure to start the transfer from inside HRAM, and wait until
the transfer has finished:</p> <div class="language- extra-class"><pre class="language-text"><code> run_dma:
  ld a, start address / 100h
  ldh  (FF46h),a ;start DMA transfer (starts right after instruction)
  ld  a,28h      ;delay...
 wait:           ;total 4x40 cycles, approx 160 μs
  dec a          ;1 cycle
  jr  nz,wait    ;3 cycles
  ret
</code></pre></div><p>Because sprites are not displayed while OAM DMA is in progress, most
programs are executing this procedure from inside of their VBlank
procedure. But it is also possible to execute it during display redraw
also, allowing to display more than 40 sprites on the screen (ie. for
example 40 sprites in upper half, and other 40 sprites in lower half of
the screen), at the cost of a couple lines that lack sprites.</p> <p>A more compact procedure is</p> <div class="language- extra-class"><pre class="language-text"><code> run_dma:  ; This part is in ROM
  ld a, start address / 100h
  ld bc, 2946h  ; B: wait time; C: OAM trigger
  jp run_dma_hrampart

 run_dma_hrampart:
  ldh ($FF00+c), a
 wait:
  dec b
  jr nz,wait
  ret
</code></pre></div><p>which should be called with a = start address / 100h, bc = 2946h. This
saves 5 bytes of HRAM, but is slightly slower in most cases because of
the jump into the HRAM part.</p> <h2 id="lcd-vram-dma-transfers-cgb-only"><a href="#lcd-vram-dma-transfers-cgb-only" class="header-anchor">#</a> LCD VRAM DMA Transfers (CGB only)</h2> <h4 id="ff51-hdma1-cgb-mode-only-new-dma-source-high"><a href="#ff51-hdma1-cgb-mode-only-new-dma-source-high" class="header-anchor">#</a> FF51 - HDMA1 - CGB Mode Only - New DMA Source, High</h4> <h4 id="ff52-hdma2-cgb-mode-only-new-dma-source-low"><a href="#ff52-hdma2-cgb-mode-only-new-dma-source-low" class="header-anchor">#</a> FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low</h4> <p>These two registers specify the address at which the transfer will read
data from. Normally, this should be either in ROM, SRAM or WRAM, thus
either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be
tested on Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source
address in VRAM will cause garbage to be copied.</p> <p>The four lower bits of this address will be ignored and treated as 0.</p> <h4 id="ff53-hdma3-cgb-mode-only-new-dma-destination-high"><a href="#ff53-hdma3-cgb-mode-only-new-dma-destination-high" class="header-anchor">#</a> FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High</h4> <h4 id="ff54-hdma4-cgb-mode-only-new-dma-destination-low"><a href="#ff54-hdma4-cgb-mode-only-new-dma-destination-low" class="header-anchor">#</a> FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low</h4> <p>These two registers specify the address within 8000-9FF0 to which the
data will be copied. Only bits 12-4 are respected; others are ignored.
The four lower bits of this address will be ignored and treated as 0.</p> <h4 id="ff55-hdma5-cgb-mode-only-new-dma-length-mode-start"><a href="#ff55-hdma5-cgb-mode-only-new-dma-length-mode-start" class="header-anchor">#</a> FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start</h4> <p>These registers are used to initiate a DMA transfer from ROM or RAM to
VRAM. The Source Start Address may be located at 0000-7FF0 or A000-DFF0,
the lower four bits of the address are ignored (treated as zero). The
Destination Start Address may be located at 8000-9FF0, the lower four
bits of the address are ignored (treated as zero), the upper 3 bits are
ignored either (destination is always in VRAM).</p> <p>Writing to this register starts the transfer, the lower 7 bits of which
specify the Transfer Length (divided by 10h, minus 1), ie. lengths of
10h-800h bytes can be defined by the values 00h-7Fh. The upper bit
indicates the Transfer Mode:</p> <p><strong>Bit7=0 - General Purpose DMA</strong></p> <p>When using this transfer method,
all data is transferred at once. The execution of the program is halted
until the transfer has completed. Note that the General Purpose DMA
blindly attempts to copy the data, even if the LCD controller is
currently accessing VRAM. So General Purpose DMA should be used only if
the Display is disabled, or during V-Blank, or (for rather short blocks)
during H-Blank. The execution of the program continues when the transfer
has been completed, and FF55 then contains a value of FFh.</p> <p><strong>Bit7=1 - H-Blank DMA</strong></p> <p>The H-Blank DMA transfers 10h bytes of
data during each H-Blank, ie. at LY=0-143, no data is transferred during
V-Blank (LY=144-153), but the transfer will then continue at LY=00. The
execution of the program is halted during the separate transfers, but
the program execution continues during the 'spaces' between each data
block. Note that the program should not change the Destination VRAM bank
(FF4F), or the Source ROM/RAM bank (in case data is transferred from
bankable memory) until the transfer has completed! (The transfer should
be paused as described below while the banks are switched)</p> <p>Reading from Register FF55 returns the remaining length (divided by 10h,
minus 1), a value of 0FFh indicates that the transfer has completed. It
is also possible to terminate an active H-Blank transfer by writing zero
to Bit 7 of FF55. In that case reading from FF55 will return how many
$10 &quot;blocks&quot; remained (minus 1) in the lower 7 bits, but Bit 7 will
be read as &quot;1&quot;. Stopping the transfer doesn't set HDMA1-4 to $FF.</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>H-Blank DMA should not be started (write to FF55) during a H-Blank
period (STAT mode 0).</p> <p>If the transfer's destination address overflows, the transfer stops
prematurely. [Note : what's the state of the registers if this happens
?]</p></div> <h4 id="confirming-if-the-dma-transfer-is-active"><a href="#confirming-if-the-dma-transfer-is-active" class="header-anchor">#</a> Confirming if the DMA Transfer is Active</h4> <p>Reading Bit 7 of FF55 can be used to confirm if the DMA transfer is
active (1=Not Active, 0=Active). This works under any circumstances -
after completion of General Purpose, or H-Blank Transfer, and after
manually terminating a H-Blank Transfer.</p> <h4 id="transfer-timings"><a href="#transfer-timings" class="header-anchor">#</a> Transfer Timings</h4> <p>In both Normal Speed and Double Speed Mode it takes about 8 μs to
transfer a block of 10h bytes. That are 8 tstates in Normal Speed Mode,
and 16 'fast' tstates in Double Speed Mode. Older MBC controllers
(like MBC1-4) and slower ROMs are not guaranteed to support General
Purpose or H-Blank DMA, that's because there are always 2 bytes
transferred per microsecond (even if the itself program runs it Normal
Speed Mode).</p> <h2 id="vram-tile-data"><a href="#vram-tile-data" class="header-anchor">#</a> VRAM Tile Data</h2> <p>Tile Data is stored in VRAM at addresses $8000-97FF; with one tile
being 16 bytes large, this area defines data for 384 Tiles. In CGB Mode,
this is doubled (768 tiles) because of the two VRAM banks.</p> <p>Each tile is sized 8x8 pixels and has a color depth of 4 colors/gray
shades. Tiles can be displayed as part of the Background/Window map,
and/or as OAM tiles (foreground sprites). Note that foreground sprites
don't use color 0 - it's transparent instead.</p> <p>There are three &quot;blocks&quot; of 128 tiles each:</p> <ul><li>Block 0 is $8000-87FF</li> <li>Block 1 is $8800-8FFF</li> <li>Block 2 is $9000-97FF</li></ul> <p>Tiles are always indexed using a 8-bit integer, but the addressing
method may differ. The &quot;8000 method&quot; uses $8000 as its base pointer
and uses an unsigned addressing, meaning that tiles 0-127 are in block
0, and tiles 128-255 are in block 1. The &quot;8800 method&quot; uses $9000 as
its base pointer and uses a signed addressing. To put it differently,
&quot;8000 addressing&quot; takes tiles 0-127 from block 0 and tiles 128-255
from block 1, whereas &quot;8800 addressing&quot; takes tiles 0-127 from block 2
and tiles 128-255 from block 1. (You can notice that block 1 is shared
by both addressing methods)</p> <p>Sprites always use 8000 addressing, but the BG and Window can use either
mode, controlled by <a href="#LCDC.4_-_BG_.26_Window_Tile_Data_Select" title="wikilink">LCDC bit
4</a>.</p> <p>Each Tile occupies 16 bytes, where each 2 bytes represent a line:</p> <div class="language- extra-class"><pre class="language-text"><code>Byte 0-1  First Line (Upper 8 pixels)
Byte 2-3  Next Line
etc.`
</code></pre></div><p>For each line, the first byte defines the least significant bits of the
color numbers for each pixel, and the second byte defines the upper bits
of the color numbers. In either case, Bit 7 is the leftmost pixel, and
Bit 0 the rightmost. For example : let's say you have $57 $36 (in
this order in memory). To obtain the color index for the leftmost pixel,
you take bit 7 of both bytes : 0, and 0. Thus the index is 00b = 0. For
the second pixel, repeat with bit 6 : 1, and 0. Thus the index is 01b =
1 (remember to flip the order of the bits !). If you repeat the
operation you'll find that the indexes for the 8 pixels are 0 1 2 3 0 3
3 1.</p> <p>A more visual explanation can be found
<a href="https://www.huderlem.com/demos/gameboy2bpp.html" target="_blank" rel="noopener noreferrer">here<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <p>So, each pixel is having a color number in range from 0-3. The color
numbers are translated into real colors (or gray shades) depending on
the current palettes. The palettes are defined through registers
<a href="#FF47_-_BGP_-_BG_Palette_Data_.28R.2FW.29_-_Non_CGB_Mode_Only" title="wikilink">BGP</a>,
<a href="#FF48_-_OBP0_-_Object_Palette_0_Data_.28R.2FW.29_-_Non_CGB_Mode_Only" title="wikilink">OBP0</a>
and
<a href="#FF49_-_OBP1_-_Object_Palette_1_Data_.28R.2FW.29_-_Non_CGB_Mode_Only" title="wikilink">OBP1</a>
(Non CGB Mode), and
<a href="#FF68_-_BCPS.2FBGPI_-_CGB_Mode_Only_-_Background_Palette_Index" title="wikilink">BCPS/BGPI</a>,
<a href="#FF69_-_BCPD.2FBGPD_-_CGB_Mode_Only_-_Background_Palette_Data" title="wikilink">BCPD/BGPD</a>,
<a href="#FF6A_-_OCPS.2FOBPI_-_CGB_Mode_Only_-_Sprite_Palette_Index.2C_FF6B_-_OCPD.2FOBPD_-_CGB_Mode_Only_-_Sprite_Palette_Data" title="wikilink">OCPS/OBPI and
OCPD/OBPD</a>
(CGB Mode).</p> <h2 id="vram-background-maps"><a href="#vram-background-maps" class="header-anchor">#</a> VRAM Background Maps</h2> <p>The Game Boy contains two 32x32 tile background maps in VRAM at
addresses 9800h-9BFFh and 9C00h-9FFFh. Each can be used either to
display &quot;normal&quot; background, or &quot;window&quot; background.</p> <h4 id="bg-map-tile-numbers"><a href="#bg-map-tile-numbers" class="header-anchor">#</a> BG Map Tile Numbers</h4> <p>An area of VRAM known as Background Tile Map contains the numbers of
tiles to be displayed. It is organized as 32 rows of 32 bytes each. Each
byte contains a number of a tile to be displayed.</p> <p>Tile patterns are taken from the Tile Data Table using either of the two
addressing modes (described <a href="#VRAM_Tile_Data" title="wikilink">above</a>), which
can be selected via LCDC register.</p> <p>As one background tile has a size of 8x8 pixels, the BG maps may hold a
picture of 256x256 pixels, and an area of 160x144 pixels of this picture
can be displayed on the LCD screen.</p> <h4 id="bg-map-attributes-cgb-mode-only"><a href="#bg-map-attributes-cgb-mode-only" class="header-anchor">#</a> BG Map Attributes (CGB Mode only)</h4> <p>In CGB Mode, an additional map of 32x32 bytes is stored in VRAM Bank 1
(each byte defines attributes for the corresponding tile-number map
entry in VRAM Bank 0, ie. 1:9800 defines the attributes for the tile at
0:9800):</p> <div class="language- extra-class"><pre class="language-text"><code>Bit 0-2  Background Palette number  (BGP0-7)
Bit 3    Tile VRAM Bank number      (0=Bank 0, 1=Bank 1)
Bit 4    Not used
Bit 5    Horizontal Flip            (0=Normal, 1=Mirror horizontally)
Bit 6    Vertical Flip              (0=Normal, 1=Mirror vertically)
Bit 7    BG-to-OAM Priority         (0=Use OAM priority bit, 1=BG Priority)
</code></pre></div><p>When Bit 7 is set, the corresponding BG tile will have priority above
all OBJs (regardless of the priority bits in OAM memory). There's also
a Master Priority flag in LCDC register Bit 0 which overrides all other
priority bits when cleared.</p> <p>Note that, if the map entry at 0:9800 is tile $2A, the attribute at
1:9800 doesn't define properties for ALL tiles $2A on-screen, but only
the one at 0:9800 !</p> <h4 id="normal-background-bg"><a href="#normal-background-bg" class="header-anchor">#</a> Normal Background (BG)</h4> <p>The SCY and SCX registers can be used to scroll the background, allowing
to select the origin of the visible 160x144 pixel area within the total
256x256 pixel background map. Background wraps around the screen (i.e.
when part of it goes off the screen, it appears on the opposite side.)</p> <h4 id="the-window"><a href="#the-window" class="header-anchor">#</a> The Window</h4> <p>Besides background, there is also a &quot;window&quot; overlaying the
background. The window is not scrollable, that is, it is always
displayed starting from its left upper corner. The location of a window
on the screen can be adjusted via WX and WY registers. Screen
coordinates of the top left corner of a window are WX-7,WY. The tiles
for the window are stored in the Tile Data Table. Both the Background
and the window share the same Tile Data Table.</p> <p>Both background and window can be disabled or enabled separately via
bits in the LCDC register.</p> <h2 id="vram-banks-cgb-only"><a href="#vram-banks-cgb-only" class="header-anchor">#</a> VRAM Banks (CGB only)</h2> <p>The CGB has twice the VRAM of the DMG, but it is banked and either bank
has a different purpose.</p> <h4 id="ff4f-vbk-cgb-mode-only-vram-bank-r-w"><a href="#ff4f-vbk-cgb-mode-only-vram-bank-r-w" class="header-anchor">#</a> FF4F - VBK - CGB Mode Only - VRAM Bank (R/W)</h4> <p>This register can be written to to change VRAM banks. Only bit 0
matters, all other bits are ignored.</p> <h4 id="vram-bank-1"><a href="#vram-bank-1" class="header-anchor">#</a> VRAM bank 1</h4> <p>VRAM bank 1 is split like VRAM bank 0 ; 8000-97FF also stores tiles
(just like in bank 0), which can be accessed the same way as (and at the
same time as) bank 0 tiles. 9800-9FFF contains the attributes for the
corresponding Tile Maps.</p> <p>Reading from this register will return the number of the currently
loaded VRAM bank in bit 0, and all other bits will be set to 1.</p> <h2 id="vram-sprite-attribute-table-oam"><a href="#vram-sprite-attribute-table-oam" class="header-anchor">#</a> VRAM Sprite Attribute Table (OAM)</h2> <p>Gameboy video controller can display up to 40 sprites either in 8x8 or
in 8x16 pixels. Because of a limitation of hardware, only ten sprites
can be displayed per scan line. Sprite patterns have the same format as
BG tiles, but they are taken from the Sprite Pattern Table located at
$8000-8FFF and have unsigned numbering.</p> <p>Sprite attributes reside in the Sprite Attribute Table (OAM - Object
Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of
four bytes with the following meanings:</p> <h4 id="byte0-y-position"><a href="#byte0-y-position" class="header-anchor">#</a> Byte0 - Y Position</h4> <p>Specifies the sprites vertical position on the screen (minus 16). An
off-screen value (for example, Y=0 or Y&gt;=160) hides the sprite.</p> <h4 id="byte1-x-position"><a href="#byte1-x-position" class="header-anchor">#</a> Byte1 - X Position</h4> <p>Specifies the sprites horizontal position on the screen (minus 8). An
off-screen value (X=0 or X&gt;=168) hides the sprite, but the sprite still
affects the priority ordering - a better way to hide a sprite is to set
its Y-coordinate off-screen.</p> <h4 id="byte2-tile-pattern-number"><a href="#byte2-tile-pattern-number" class="header-anchor">#</a> Byte2 - Tile/Pattern Number</h4> <p>Specifies the sprites Tile Number (00-FF). This (unsigned) value selects
a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in
VRAM Bank 0 or 1, depending on Bit 3 of the following byte. In 8x16
mode, the lower bit of the tile number is ignored. IE: the upper 8x8
tile is &quot;NN AND FEh&quot;, and the lower 8x8 tile is &quot;NN OR 01h&quot;.</p> <h4 id="byte3-attributes-flags"><a href="#byte3-attributes-flags" class="header-anchor">#</a> Byte3 - Attributes/Flags:</h4> <div class="language- extra-class"><pre class="language-text"><code> Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
        (Used for both BG and Window. BG color 0 is always behind OBJ)
 Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
 Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
 Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
 Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
 Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)
</code></pre></div><h4 id="sprite-priorities-and-conflicts"><a href="#sprite-priorities-and-conflicts" class="header-anchor">#</a> Sprite Priorities and Conflicts</h4> <p>During each scanline's OAM scan, the LCD controller compares LY to each
sprite's Y position to find the 10 sprites on that line that appear
first in OAM ($FE00-$FE03 being the first). It discards the rest,
allowing only 10 sprites to be displayed on any one line. When this
limit is exceeded, sprites appearing later in OAM won't be displayed.
To keep unused sprites from affecting onscreen sprites, set their Y
coordinate to Y = 0 or Y &gt;= 160 (144 + 16) (Note : Y &lt;= 8 also works
if sprite size is set to 8x8). Just setting the X coordinate to X = 0 or
X &gt;= 168 (160 + 8) on a sprite will hide it, but it will still affect
other sprites sharing the same lines.</p> <p>If using <a href="BGB" title="wikilink">BGB</a>, in the VRAM viewer - OAM tab, hover your
mouse over the small screen to highlight the sprites on a line. Sprites
hidden due to the limitation will be highlighted in red.</p> <p>When these 10 sprites overlap, the highest priority one will appear
above all others, etc. (Thus, no Z-fighting.) In CGB mode, the first
sprite in OAM ($FE00-$FE03) has the highest priority, and so on. In
Non-CGB mode, the smaller the X coordinate, the higher the priority. The
tie breaker (same X coordinates) is the same priority as in CGB mode.</p> <p>The priority calculation between sprites disregards OBJ-to-BG Priority
(attribute bit 7). Only the highest-priority nonzero sprite pixel at any
given point is compared against the background. Thus if a sprite with a
higher priority (based on OAM index) but with OBJ-to-BG Priority turned
on overlaps a sprite with a lower priority and a nonzero background
pixel, the background pixel is displayed regardless of the
lower-priority sprite's OBJ-to-BG Priority.</p> <h4 id="writing-data-to-oam-memory"><a href="#writing-data-to-oam-memory" class="header-anchor">#</a> Writing Data to OAM Memory</h4> <p>The recommended method is to write the data to normal RAM first, and to
copy that RAM to OAM by using the DMA transfer function, initiated
through DMA register (FF46). Beside for that, it is also possible to
write data directly to the OAM area by using normal LD commands, this
works only during the H-Blank and V-Blank periods. The current state of
the LCD controller can be read out from the STAT register (FF41).</p> <h2 id="accessing-vram-and-oam"><a href="#accessing-vram-and-oam" class="header-anchor">#</a> Accessing VRAM and OAM</h2> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>When the LCD Controller is drawing the screen it is directly reading
from Video Memory (VRAM) and from the Sprite Attribute Table (OAM).
During these periods the Game Boy CPU may not access the VRAM and OAM.
That means, any attempts to write to VRAM/OAM are ignored (the data
remains unchanged). And any attempts to read from VRAM/OAM will return
undefined data (typically a value of FFh).</p> <p>For this reason the program should verify if VRAM/OAM is accessible
before actually reading or writing to it. This is usually done by
reading the Mode Bits from the STAT Register (FF41). When doing this (as
described in the examples below) you should take care that no interrupts
occur between the wait loops and the following memory access - the
memory is guaranteed to be accessible only for a few cycles directly
after the wait loops have completed.</p></div> <h4 id="vram-memory-at-8000h-9fffh-is-accessible-during-mode-0-2"><a href="#vram-memory-at-8000h-9fffh-is-accessible-during-mode-0-2" class="header-anchor">#</a> VRAM (memory at 8000h-9FFFh) is accessible during Mode 0-2</h4> <div class="language- extra-class"><pre class="language-text"><code>Mode 0 - H-Blank Period,
Mode 1 - V-Blank Period, and
Mode 2 - Searching OAM Period
</code></pre></div><p>A typical procedure that waits for accessibility of VRAM would be:</p> <div class="language- extra-class"><pre class="language-text"><code>ld   hl,0FF41h    ;-STAT Register
@@wait:           ;
bit  1,(hl)       ; Wait until Mode is 0 or 1
jr   nz,@@wait    ;
</code></pre></div><p>Even if the procedure gets executed at the <em>end</em> of Mode 0 or 1, it is
still proof to assume that VRAM can be accessed for a few more cycles
because in either case the following period is Mode 2 which allows
access to VRAM either. However, be careful about STAT LCD interrupts or
other interrupts that could cause the LCD to be back in mode 3 by the
time it returns. In CGB Mode an alternate method to write data to VRAM
is to use the HDMA Function (FF51-FF55).</p> <p>If you're not using LCD interrupts, another way to synchronize to the
start of mode 0 is to use <code>halt</code> with IME turned off (<code>di</code>). This allows
use of the entire mode 0 on one line and mode 2 on the following line,
which sum to 165 to 288 dots. For comparison, at single speed (4 dots
per machine cycle), a <a href="Popslide" title="wikilink">copy from stack</a> that takes
9 cycles per 2 bytes can push 8 bytes (half a tile) in 144 dots, which
fits within the worst case timing for mode 0+2.</p> <h4 id="oam-memory-at-fe00h-fe9fh-is-accessible-during-mode-0-1"><a href="#oam-memory-at-fe00h-fe9fh-is-accessible-during-mode-0-1" class="header-anchor">#</a> OAM (memory at FE00h-FE9Fh) is accessible during Mode 0-1</h4> <div class="language- extra-class"><pre class="language-text"><code>Mode 0 - H-Blank Period
Mode 1 - V-Blank Period
</code></pre></div><p>Aside from that, OAM can be accessed at any time by using the DMA
Function (FF46). When directly reading or writing to OAM, a typical
procedure that waits for accessibility of OAM Memory would be:</p> <div class="language- extra-class"><pre class="language-text"><code> ld   hl,0FF41h    ;-STAT Register
@@wait1:           ;
 bit  1,(hl)       ; Wait until Mode is -NOT- 0 or 1
 jr   z,@@wait1    ;
@@wait2:           ;
 bit  1,(hl)       ; Wait until Mode 0 or 1 -BEGINS-
 jr   nz,@@wait2   ;
</code></pre></div><p>The two wait loops ensure that Mode 0 or 1 will last for a few clock
cycles after completion of the procedure. In V-Blank period it might be
recommended to skip the whole procedure - and in most cases using the
above mentioned DMA function would be more recommended anyways.</p> <div class="custom-block tip"><p class="custom-block-title">NOTE</p> <p>When the display is disabled, both VRAM and OAM are accessible at any
time. The downside is that the screen is blank (white) during this
period, so that disabling the display would be recommended only during
initialization.</p></div> <h1 id="sound-controller"><a href="#sound-controller" class="header-anchor">#</a> Sound Controller</h1> <p>There are two sound channels connected to the output terminals SO1 and
SO2. There is also a input terminal Vin connected to the cartridge. It
can be routed to either of both output terminals. Game Boy circuitry
allows producing sound in four different ways:</p> <div class="language- extra-class"><pre class="language-text"><code>Quadrangular wave patterns with sweep and envelope functions
Quadrangular wave patterns with envelope functions
Voluntary wave patterns from wave RAM
White noise with an envelope function
</code></pre></div><p>These four sounds can be controlled independantly and then mixed
separately for each of the output terminals.</p> <p>Sound registers may be set at all times while producing sound.</p> <p>(Sounds will have a 2.4% higher frequency on Super GB.)</p> <h2 id="sound-channel-1-tone-sweep"><a href="#sound-channel-1-tone-sweep" class="header-anchor">#</a> Sound Channel 1 - Tone &amp; Sweep</h2> <h4 id="ff10-nr10-channel-1-sweep-register-r-w"><a href="#ff10-nr10-channel-1-sweep-register-r-w" class="header-anchor">#</a> FF10 - NR10 - Channel 1 Sweep register (R/W)</h4> <div class="language- extra-class"><pre class="language-text"><code> Bit 6-4 - Sweep Time
 Bit 3   - Sweep Increase/Decrease
            0: Addition    (frequency increases)
            1: Subtraction (frequency decreases)
 Bit 2-0 - Number of sweep shift (n: 0-7)
</code></pre></div><p>Sweep Time:</p> <div class="language- extra-class"><pre class="language-text"><code>000: sweep off - no freq change
001: 7.8 ms  (1/128Hz)
010: 15.6 ms (2/128Hz)
011: 23.4 ms (3/128Hz)
100: 31.3 ms (4/128Hz)
101: 39.1 ms (5/128Hz)
110: 46.9 ms (6/128Hz)
111: 54.7 ms (7/128Hz)
</code></pre></div><p>The change of frequency (NR13,NR14) at each shift is calculated by the
following formula where X(0) is initial freq &amp; X(t-1) is last freq:</p> <p><code>X(t) = X(t-1) +/- X(t-1)/2^n</code></p> <h4 id="ff11-nr11-channel-1-sound-length-wave-pattern-duty-r-w"><a href="#ff11-nr11-channel-1-sound-length-wave-pattern-duty-r-w" class="header-anchor">#</a> FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)</h4> <div class="language- extra-class"><pre class="language-text"><code>Bit 7-6 - Wave Pattern Duty (Read/Write)
Bit 5-0 - Sound length data (Write Only) (t1: 0-63)
</code></pre></div><p>Wave Duty:</p> <div class="language- extra-class"><pre class="language-text"><code>00: 12.5% ( _-------_-------_------- )
01: 25%   ( __------__------__------ )
10: 50%   ( ____----____----____---- ) (normal)
11: 75%   ( ______--______--______-- )
</code></pre></div><p>Sound Length = (64-t1)*(1/256) seconds The Length value is used only if
Bit 6 in NR14 is set.</p> <h4 id="ff12-nr12-channel-1-volume-envelope-r-w"><a href="#ff12-nr12-channel-1-volume-envelope-r-w" class="header-anchor">#</a> FF12 - NR12 - Channel 1 Volume Envelope (R/W)</h4> <div class="language- extra-class"><pre class="language-text"><code> Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
 Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
 Bit 2-0 - Number of envelope sweep (n: 0-7)
           (If zero, stop envelope operation.)
</code></pre></div><p>Length of 1 step = n*(1/64) seconds</p> <h4 id="ff13-nr13-channel-1-frequency-lo-write-only"><a href="#ff13-nr13-channel-1-frequency-lo-write-only" class="header-anchor">#</a> FF13 - NR13 - Channel 1 Frequency lo (Write Only)</h4> <p>Lower 8 bits of 11 bit frequency (x). Next 3 bit are in NR14 ($FF14)</p> <h4 id="ff14-nr14-channel-1-frequency-hi-r-w"><a href="#ff14-nr14-channel-1-frequency-hi-r-w" class="header-anchor">#</a> FF14 - NR14 - Channel 1 Frequency hi (R/W)</h4> <p><code>Bit 7   - Initial (1=Restart Sound)     (Write Only)</code><br> <code>Bit 6   - Counter/consecutive selection (Read/Write)</code><br> <code>(1=Stop output when length in NR11 expires)</code><br> <code>Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)</code></p> <p>Frequency = 131072/(2048-x) Hz</p> <h2 id="sound-channel-2-tone"><a href="#sound-channel-2-tone" class="header-anchor">#</a> Sound Channel 2 - Tone</h2> <p>This sound channel works exactly as channel 1, except that it doesn't
have a Tone Envelope/Sweep Register.</p> <h4 id="ff16-nr21-channel-2-sound-length-wave-pattern-duty-r-w"><a href="#ff16-nr21-channel-2-sound-length-wave-pattern-duty-r-w" class="header-anchor">#</a> FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)</h4> <p><code>Bit 7-6 - Wave Pattern Duty (Read/Write)</code><br> <code>Bit 5-0 - Sound length data (Write Only) (t1: 0-63)</code></p> <p>Wave Duty:</p> <p><code>00: 12.5% ( _-------_-------_------- )</code><br> <code>01: 25%   ( __------__------__------ )</code><br> <code>10: 50%   ( ____----____----____---- ) (normal)</code><br> <code>11: 75%   ( ______--______--______-- )</code></p> <p>Sound Length = (64-t1)*(1/256) seconds The Length value is used only if
Bit 6 in NR24 is set.</p> <h4 id="ff17-nr22-channel-2-volume-envelope-r-w"><a href="#ff17-nr22-channel-2-volume-envelope-r-w" class="header-anchor">#</a> FF17 - NR22 - Channel 2 Volume Envelope (R/W)</h4> <p><code>Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)</code><br> <code>Bit 3   - Envelope Direction (0=Decrease, 1=Increase)</code><br> <code>Bit 2-0 - Number of envelope sweep (n: 0-7)</code><br> <code>(If zero, stop envelope operation.)</code></p> <p>Length of 1 step = n*(1/64) seconds</p> <h4 id="ff18-nr23-channel-2-frequency-lo-data-w"><a href="#ff18-nr23-channel-2-frequency-lo-data-w" class="header-anchor">#</a> FF18 - NR23 - Channel 2 Frequency lo data (W)</h4> <p>Frequency's lower 8 bits of 11 bit data (x). Next 3 bits are in NR24
($FF19).</p> <h4 id="ff19-nr24-channel-2-frequency-hi-data-r-w"><a href="#ff19-nr24-channel-2-frequency-hi-data-r-w" class="header-anchor">#</a> FF19 - NR24 - Channel 2 Frequency hi data (R/W)</h4> <p><code>Bit 7   - Initial (1=Restart Sound)     (Write Only)</code><br> <code>Bit 6   - Counter/consecutive selection (Read/Write)</code><br> <code>(1=Stop output when length in NR21 expires)</code><br> <code>Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)</code></p> <p>Frequency = 131072/(2048-x) Hz</p> <h2 id="sound-channel-3-wave-output"><a href="#sound-channel-3-wave-output" class="header-anchor">#</a> Sound Channel 3 - Wave Output</h2> <p>This channel can be used to output digital sound, the length of the
sample buffer (Wave RAM) is limited to 32 digits. This sound channel can
be also used to output normal tones when initializing the Wave RAM by a
square wave. This channel doesn't have a volume envelope register.</p> <h4 id="ff1a-nr30-channel-3-sound-on-off-r-w"><a href="#ff1a-nr30-channel-3-sound-on-off-r-w" class="header-anchor">#</a> FF1A - NR30 - Channel 3 Sound on/off (R/W)</h4> <p><code>Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)</code></p> <h4 id="ff1b-nr31-channel-3-sound-length"><a href="#ff1b-nr31-channel-3-sound-length" class="header-anchor">#</a> FF1B - NR31 - Channel 3 Sound Length</h4> <p><code>Bit 7-0 - Sound length (t1: 0 - 255)</code></p> <p>Sound Length = (256-t1)*(1/256) seconds This value is used only if Bit
6 in NR34 is set.</p> <h4 id="ff1c-nr32-channel-3-select-output-level-r-w"><a href="#ff1c-nr32-channel-3-select-output-level-r-w" class="header-anchor">#</a> FF1C - NR32 - Channel 3 Select output level (R/W)</h4> <p><code>Bit 6-5 - Select output level (Read/Write)</code></p> <p>Possible Output levels are:</p> <p><code>0: Mute (No sound)</code><br> <code>1: 100% Volume (Produce Wave Pattern RAM Data as it is)</code><br> <code>2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)</code><br> <code>3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)</code></p> <h4 id="ff1d-nr33-channel-3-frequency-s-lower-data-w"><a href="#ff1d-nr33-channel-3-frequency-s-lower-data-w" class="header-anchor">#</a> FF1D - NR33 - Channel 3 Frequency's lower data (W)</h4> <p>Lower 8 bits of an 11 bit frequency (x).</p> <h4 id="ff1e-nr34-channel-3-frequency-s-higher-data-r-w"><a href="#ff1e-nr34-channel-3-frequency-s-higher-data-r-w" class="header-anchor">#</a> FF1E - NR34 - Channel 3 Frequency's higher data (R/W)</h4> <p><code>Bit 7   - Initial (1=Restart Sound)     (Write Only)</code><br> <code>Bit 6   - Counter/consecutive selection (Read/Write)</code><br> <code>(1=Stop output when length in NR31 expires)</code><br> <code>Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)</code></p> <p>Frequency = 4194304/(64*(2048-x)) Hz = 65536/(2048-x) Hz</p> <h4 id="ff30-ff3f-wave-pattern-ram"><a href="#ff30-ff3f-wave-pattern-ram" class="header-anchor">#</a> FF30-FF3F - Wave Pattern RAM</h4> <p><code>Contents - Waveform storage for arbitrary sound data</code></p> <p>This storage area holds 32 4-bit samples that are played back, upper 4
bits first.</p> <p>Wave RAM should only be accessed while CH3 is disabled (NR30 bit 7
reset), otherwise accesses will behave weirdly.</p> <p>On almost all models, the byte will be written at the offset CH3 is
currently reading. On GBA, the write will simply be ignored.</p> <h2 id="sound-channel-4-noise"><a href="#sound-channel-4-noise" class="header-anchor">#</a> Sound Channel 4 - Noise</h2> <p>This channel is used to output white noise. This is done by randomly
switching the amplitude between high and low at a given frequency.
Depending on the frequency the noise will appear 'harder' or
'softer'.</p> <p>It is also possible to influence the function of the random generator,
so the that the output becomes more regular, resulting in a limited
ability to output Tone instead of Noise.</p> <h4 id="ff20-nr41-channel-4-sound-length-r-w"><a href="#ff20-nr41-channel-4-sound-length-r-w" class="header-anchor">#</a> FF20 - NR41 - Channel 4 Sound Length (R/W)</h4> <p><code>Bit 5-0 - Sound length data (t1: 0-63)</code></p> <p>Sound Length = (64-t1)*(1/256) seconds The Length value is used only if
Bit 6 in NR44 is set.</p> <h4 id="ff21-nr42-channel-4-volume-envelope-r-w"><a href="#ff21-nr42-channel-4-volume-envelope-r-w" class="header-anchor">#</a> FF21 - NR42 - Channel 4 Volume Envelope (R/W)</h4> <p><code>Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)</code><br> <code>Bit 3   - Envelope Direction (0=Decrease, 1=Increase)</code><br> <code>Bit 2-0 - Number of envelope sweep (n: 0-7)</code><br> <code>(If zero, stop envelope operation.)</code></p> <p>Length of 1 step = n*(1/64) seconds</p> <h4 id="ff22-nr43-channel-4-polynomial-counter-r-w"><a href="#ff22-nr43-channel-4-polynomial-counter-r-w" class="header-anchor">#</a> FF22 - NR43 - Channel 4 Polynomial Counter (R/W)</h4> <p>The amplitude is randomly switched between high and low at the given
frequency. A higher frequency will make the noise to appear 'softer'.
When Bit 3 is set, the output will become more regular, and some
frequencies will sound more like Tone than Noise.</p> <div class="language- extra-class"><pre class="language-text"><code>Bit 7-4 - Shift Clock Frequency (s)
Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
Bit 2-0 - Dividing Ratio of Frequencies (r)
</code></pre></div><p>Frequency = 524288 Hz / r / 2^(s+1) ;For r=0 assume r=0.5 instead</p> <h4 id="ff23-nr44-channel-4-counter-consecutive-inital-r-w"><a href="#ff23-nr44-channel-4-counter-consecutive-inital-r-w" class="header-anchor">#</a> FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)</h4> <div class="language- extra-class"><pre class="language-text"><code>Bit 7   - Initial (1=Restart Sound)     (Write Only)
Bit 6   - Counter/consecutive selection (Read/Write)
          (1=Stop output when length in NR41 expires)
</code></pre></div><h2 id="sound-control-registers"><a href="#sound-control-registers" class="header-anchor">#</a> Sound Control Registers</h2> <h4 id="ff24-nr50-channel-control-on-off-volume-r-w"><a href="#ff24-nr50-channel-control-on-off-volume-r-w" class="header-anchor">#</a> FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)</h4> <p>The volume bits specify the &quot;Master Volume&quot; for Left/Right sound
output. SO2 goes to the left headphone, and SO1 goes to the right.</p> <div class="language- extra-class"><pre class="language-text"><code>Bit 7   - Output Vin to SO2 terminal (1=Enable)
Bit 6-4 - SO2 output level (volume)  (0-7)
Bit 3   - Output Vin to SO1 terminal (1=Enable)
Bit 2-0 - SO1 output level (volume)  (0-7)
</code></pre></div><p>The Vin signal is an analog signal received from the game cartridge bus,
allowing external hardware in the cartridge to supply a fifth sound
channel, additionally to the Game Boy's internal four channels. No
licensed games used this feature, and it was omitted from the Game Boy
Advance.</p> <p>(Despite rumors, <em>Pocket Music</em> does not use Vin. It blocks use on the
GBA for a different reason: the developer couldn't figure out how to
silence buzzing associated with the wave channel's DAC.)</p> <h4 id="ff25-nr51-selection-of-sound-output-terminal-r-w"><a href="#ff25-nr51-selection-of-sound-output-terminal-r-w" class="header-anchor">#</a> FF25 - NR51 - Selection of Sound output terminal (R/W)</h4> <p>Each channel can be panned hard left, center, or hard right.</p> <div class="language- extra-class"><pre class="language-text"><code>Bit 7 - Output sound 4 to SO2 terminal
Bit 6 - Output sound 3 to SO2 terminal
Bit 5 - Output sound 2 to SO2 terminal
Bit 4 - Output sound 1 to SO2 terminal
Bit 3 - Output sound 4 to SO1 terminal
Bit 2 - Output sound 3 to SO1 terminal
Bit 1 - Output sound 2 to SO1 terminal
Bit 0 - Output sound 1 to SO1 terminal
</code></pre></div><h4 id="ff26-nr52-sound-on-off"><a href="#ff26-nr52-sound-on-off" class="header-anchor">#</a> FF26 - NR52 - Sound on/off</h4> <p>If your GB programs don't use sound then write 00h to this register to
save 16% or more on GB power consumption. Disabeling the sound
controller by clearing Bit 7 destroys the contents of all sound
registers. Also, it is not possible to access any sound registers
(execpt FF26) while the sound controller is disabled.</p> <div class="language- extra-class"><pre class="language-text"><code> Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
 Bit 3 - Sound 4 ON flag (Read Only)
 Bit 2 - Sound 3 ON flag (Read Only)
 Bit 1 - Sound 2 ON flag (Read Only)
 Bit 0 - Sound 1 ON flag (Read Only)
</code></pre></div><p>Bits 0-3 of this register are read only status bits, writing to these
bits does NOT enable/disable sound. The flags get set when sound output
is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag
remains set until the sound length has expired (if enabled). A volume
envelopes which has decreased to zero volume will NOT cause the sound
flag to go off.</p> <h2 id="pitfalls"><a href="#pitfalls" class="header-anchor">#</a> Pitfalls</h2> <ul><li>Enabling or disabling a DAC (resetting NR30 bit 7 or writing %0000
0XXX to NRx2 for other channels), adding or removing it using NR51,
or changing the volume in NR50, will cause an audio pop. (This
causes a change in DC offset, which is smoothed out by a high-pass
circuit over time, but still creates a pop)</li> <li>The final output goes through a high-pass filter, which is more
aggressive on GBA than on GBC, which is more aggressive than on DMG.
(What this means is that the output is &quot;pulled&quot; towards 0V with
various degrees of &quot;aggressiveness&quot;)</li> <li>When first starting up a pulse channel, it will <em>always</em> output a
(digital) zero.</li> <li>The pulse channels' &quot;duty step&quot; (at which position in the duty
cycle they are) can't be reset. The exception to this is turning
off the APU, which causes them to start over from 0 when turning it
on.</li> <li>Restarting a pulse channel causes its &quot;duty step timer&quot; to reset,
meaning that &quot;tickling&quot; a pulse channel regularly enough will
cause its &quot;duty step&quot; to never advance.</li> <li>When restarting CH3, it resumes playing the last 4-bit sample it
read from wave RAM, or 0 if no sample has been read since APU reset.
(Sample latching is independent of output level control in NR32.)
After the latched sample completes, it starts with the second sample
in wave RAM (low 4 bits of $FF30). The first sample (high 4 bits of
$FF30) is played last.</li> <li>CH3 output level control does not, in fact, alter the output level.
It shifts the <strong>digital</strong> value CH3 is outputting (read below), not
the analog value.</li> <li>On GBA, CH3 is inverted. This causes the channel to output a loud
spike when disabled; it's a good idea to &quot;remove&quot; the channel
using NR51 before refreshing wave RAM.</li></ul> <h2 id="apu-technical-explanation"><a href="#apu-technical-explanation" class="header-anchor">#</a> APU technical explanation</h2> <h4 id="game-boy-game-boy-color"><a href="#game-boy-game-boy-color" class="header-anchor">#</a> Game Boy, Game Boy Color</h4> <p>Each of the 4 channels work pretty identically. First, there's a
&quot;generation&quot; circuit, which usually outputs either a 0 or another
value (CH3 differs in that it can output multiple values, but
regardless). That value is digital, and can range between 0 and 0xF.
This is then fed to a
<a href="https://en.wikipedia.org/wiki/Digital-to-analog_converter" target="_blank" rel="noopener noreferrer">DAC<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, which
maps this to an analog value; 7 maps to the lowest (negative) voltage, 0
to the highest (positive) one. Finally, all channels are mixed through
NR51, scaled through NR50, and sent to the output.</p> <p>Each DAC is controlled independently from the generation circuit. For
CH3, the DAC is controlled by NR30 bit 7; for other channels, the DAC is
turned on unless bits 3-7 of NRx2 are reset, and the envelope will be
set to <code>[NRx2] &gt;&gt; 4</code>. (Note: the envelope sweep function changes the
envelope, but not the value in NRx2! It won't disable the DAC, either.)
The generation circuits are turned on by restarting them for the first
time, and this is what sets the corresponding bit in NR52. Yes, it's
possible to turn on a DAC but not the generation circuit. Finally,
disabling a DAC also kills the generation circuit.</p> <p>Note that each DAC has a DC offset, so enabling, disabling, adding to or
removing from NR51, will all cause an audio pop; changing the volume in
NR50 will as well.</p> <p>Finally, all the output goes through a high-pass filter to remove the DC
offsets from the DACs.</p> <h4 id="game-boy-advance"><a href="#game-boy-advance" class="header-anchor">#</a> Game Boy Advance</h4> <p>The APU was reworked pretty heavily for the GBA. Instead of mixing being
done analogically, it's instead done digitally; then, sound is
converted to an analog signal and an offset is added (see SOUNDBIAS in
<a href="http://problemkaputt.de/gbatek.htm#gbasoundcontrolregisters" target="_blank" rel="noopener noreferrer">GBATEK<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
for more details.</p> <p>This means that the APU has no DACs, or if modelling the GBA as a GB,
they're always on.</p> <h1 id="joypad-input"><a href="#joypad-input" class="header-anchor">#</a> Joypad Input</h1> <h4 id="ff00-p1-joyp-joypad-r-w"><a href="#ff00-p1-joyp-joypad-r-w" class="header-anchor">#</a> FF00 - P1/JOYP - Joypad (R/W)</h4> <p>The eight Game Boy buttons/direction keys are arranged in form of a 2x4
matrix. Select either button or direction keys by writing to this
register, then read-out bit 0-3.</p> <div class="language- extra-class"><pre class="language-text"><code>Bit 7 - Not used
Bit 6 - Not used
Bit 5 - P15 Select Button Keys      (0=Select)
Bit 4 - P14 Select Direction Keys   (0=Select)
Bit 3 - P13 Input Down  or Start    (0=Pressed) (Read Only)
Bit 2 - P12 Input Up    or Select   (0=Pressed) (Read Only)
Bit 1 - P11 Input Left  or Button B (0=Pressed) (Read Only)
Bit 0 - P10 Input Right or Button A (0=Pressed) (Read Only)
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">NOTE</p> <p>Most programs are repeatedly reading from this port several times
(the first reads used as short delay, allowing the inputs to stabilize,
and only the value from the last read actually used).</p></div> <h4 id="usage-in-sgb-software"><a href="#usage-in-sgb-software" class="header-anchor">#</a> Usage in SGB software</h4> <p>Beside for normal joypad input, SGB games mis-use the joypad register to
output SGB command packets to the SNES, also, SGB programs may read out
gamepad states from up to four different joypads which can be connected
to the SNES. See SGB description for details.</p> <h4 id="int-60-joypad-interrupt"><a href="#int-60-joypad-interrupt" class="header-anchor">#</a> INT 60 - Joypad Interrupt</h4> <p>Joypad interrupt is requested when any of the above Input lines changes
from High to Low. Generally this should happen when a key becomes
pressed (provided that the button/direction key is enabled by above
Bit4/5), however, because of switch bounce, one or more High to Low
transitions are usually produced both when pressing or releasing a key.</p> <h4 id="using-the-joypad-interrupt"><a href="#using-the-joypad-interrupt" class="header-anchor">#</a> Using the Joypad Interrupt</h4> <p>It's more or less useless for programmers, even when selecting both
buttons and direction keys simultaneously it still cannot recognize all
keystrokes, because in that case a bit might be already held low by a
button key, and pressing the corresponding direction key would thus
cause no difference. The only meaningful purpose of the keystroke
interrupt would be to terminate STOP (low power) standby state. GBA SP,
because of the different buttons used, seems to not be affected by
switch bounce.</p> <h1 id="serial-data-transfer"><a href="#serial-data-transfer" class="header-anchor">#</a> Serial Data Transfer</h1> <p>Communication between two Gameboys happens one byte at a time. One
Gameboy acts as the master, uses its internal clock, and thus controls
when the exchange happens. The other one uses an external clock (i.e.,
the one inside the other Gameboy) and has no control over when the
transfer happens. If it hasn't gotten around to loading up the next
data byte at the time the transfer begins, the last one will go out
again. Alternately, if it's ready to send the next byte but the last
one hasn't gone out yet, it has no choice but to wait.</p> <h4 id="ff01-sb-serial-transfer-data-r-w"><a href="#ff01-sb-serial-transfer-data-r-w" class="header-anchor">#</a> FF01 - SB - Serial transfer data (R/W)</h4> <p>Before a transfer, it holds the next byte that will go out.</p> <p>During a transfer, it has a blend of the outgoing and incoming bytes.
Each cycle, the leftmost bit is shifted out (and over the wire) and the
incoming bit is shifted in from the other side:</p> <div class="language- extra-class"><pre class="language-text"><code>o7 o6 o5 o4 o3 o2 o1 o0
o6 o5 o4 o3 o2 o1 o0 i7
o5 o4 o3 o2 o1 o0 i7 i6
o4 o3 o2 o1 o0 i7 i6 i5
o3 o2 o1 o0 i7 i6 i5 i4
o2 o1 o0 i7 i6 i5 i4 i3
o1 o0 i7 i6 i5 i4 i3 i2
o0 i7 i6 i5 i4 i3 i2 i1
i7 i6 i5 i4 i3 i2 i1 i0
</code></pre></div><h4 id="ff02-sc-serial-transfer-control-r-w"><a href="#ff02-sc-serial-transfer-control-r-w" class="header-anchor">#</a> FF02 - SC - Serial Transfer Control (R/W)</h4> <div class="language- extra-class"><pre class="language-text"><code>Bit 7 - Transfer Start Flag (0=No transfer is in progress or requested, 1=Transfer in progress, or requested)
Bit 1 - Clock Speed (0=Normal, 1=Fast) ** CGB Mode Only **
Bit 0 - Shift Clock (0=External Clock, 1=Internal Clock)
</code></pre></div><p>The Game Boy acting as master will load up a data byte in SB and then set
SC to 0x81 (Transfer requested, use internal clock). It will be notified
that the transfer is complete in two ways: SC's Bit 7 will be cleared
(i.e., SC will be set up 0x01), and also the Serial Interrupt handler
will be called (i.e., the CPU will jump to 0x0058).</p> <p>The other Game Boy will load up a data byte and can optionally set SC's
Bit 7 (i.e., SC=0x80). Regardless of whether or not it has done this, if
and when the master Game Boy wants to conduct a transfer, it will happen
(pulling whatever happens to be in SB at that time). The passive gameboy
will have its serial interrupt handler called at the end of the
transfer, and if it bothered to set SC's Bit 7, it will be cleared.</p> <h4 id="internal-clock"><a href="#internal-clock" class="header-anchor">#</a> Internal Clock</h4> <p>In Non-CGB Mode the Game Boy supplies an internal clock of 8192Hz only
(allowing to transfer about 1 KByte per second). In CGB Mode four
internal clock rates are available, depending on Bit 1 of the SC
register, and on whether the CGB Double Speed Mode is used:</p> <div class="language- extra-class"><pre class="language-text"><code>   8192Hz -  1KB/s - Bit 1 cleared, Normal
  16384Hz -  2KB/s - Bit 1 cleared, Double Speed Mode
 262144Hz - 32KB/s - Bit 1 set,     Normal
 524288Hz - 64KB/s - Bit 1 set,     Double Speed Mode
</code></pre></div><h4 id="external-clock"><a href="#external-clock" class="header-anchor">#</a> External Clock</h4> <p>The external clock is typically supplied by another gameboy, but might
be supplied by another computer (for example if connected to a PCs
parallel port), in that case the external clock may have any speed. Even
the old/monochrome Game Boy is reported to recognizes external clocks of
up to 500KHz. And there is no limitation into the other direction - even
when suppling an external clock speed of &quot;1 bit per month&quot;, then the
gameboy will still eagerly wait for the next bit(s) to be transferred.
It isn't required that the clock pulses are sent at an regular interval
either.</p> <h4 id="timeouts"><a href="#timeouts" class="header-anchor">#</a> Timeouts</h4> <p>When using external clock then the transfer will not complete until the
last bit is received. In case that the second Game Boy isn't supplying a
clock signal, if it gets turned off, or if there is no second gameboy
connected at all) then transfer will never complete. For this reason the
transfer procedure should use a timeout counter, and abort the
communication if no response has been received during the timeout
interval.</p> <h4 id="delays-and-synchronization"><a href="#delays-and-synchronization" class="header-anchor">#</a> Delays and Synchronization</h4> <p>The Game Boy that is using internal clock should always execute a small
delay between each transfer, in order to ensure that the opponent
gameboy has enough time to prepare itself for the next transfer, ie. the
gameboy with external clock must have set its transfer start bit before
the Game Boy with internal clock starts the transfer. Alternately, the
two gameboys could switch between internal and external clock for each
transferred byte to ensure synchronization.</p> <p>Transfer is initiated by setting the master Game Boy setting its Transfer
Start Flag, regardless of the value of this flag on the other device.
This bit is automatically set to 0 (on both) at the end of Transfer.
Reading this bit can be used to determine if the transfer is still
active.</p> <h4 id="int-58-serial-interrupt"><a href="#int-58-serial-interrupt" class="header-anchor">#</a> INT 58 - Serial Interrupt</h4> <p>When the transfer has completed (ie. after sending/receiving 8 bits, if
any) then an interrupt is requested by setting Bit 3 of the IF Register
(FF0F). When that interrupt is enabled, then the Serial Interrupt vector
at 0058 is called.</p> <p><strong>XXXXXX...</strong></p> <p>Transmitting and receiving serial data is done simultaneously. The
received data is automatically stored in SB.</p> <p>The serial I/O port on the Game Boy is a very simple setup and is crude
compared to standard RS-232 (IBM-PC) or RS-485 (Macintosh) serial ports.
There are no start or stop bits.</p> <p>During a transfer, a byte is shifted in at the same time that a byte is
shifted out. The rate of the shift is determined by whether the clock
source is internal or external. The most significant bit is shifted in
and out first.</p> <p>When the internal clock is selected, it drives the clock pin on the game
link port and it stays high when not used. During a transfer it will go
low eight times to clock in/out each bit.</p> <p>The state of the last bit shifted out determines the state of the output
line until another transfer takes place.</p> <p>If a serial transfer with internal clock is performed and no external
GameBoy is present, a value of $FF will be received in the transfer.</p> <p>The following code initiates the process of shifting $75 out the serial
port and a byte to be shifted into $FF01:</p> <div class="language- extra-class"><pre class="language-text"><code>   ld   a,$75
   ld  ($FF01),a
   ld   a,$81
   ld  ($FF02),a
</code></pre></div><p>The Game Boy does not support wake-on-LAN. Completion of an externally
clocked serial transfer does not exit STOP mode.</p> <h1 id="timer-and-divider-registers"><a href="#timer-and-divider-registers" class="header-anchor">#</a> Timer and Divider Registers</h1> <h4 id="ff04-div-divider-register-r-w"><a href="#ff04-div-divider-register-r-w" class="header-anchor">#</a> FF04 - DIV - Divider Register (R/W)</h4> <p>This register is incremented at rate of 16384Hz (~16779Hz on SGB).
Writing any value to this register resets it to 00h.</p> <p>Note: The divider is affected by CGB double speed mode, and will
increment at 32768Hz in double speed.</p> <h4 id="ff05-tima-timer-counter-r-w"><a href="#ff05-tima-timer-counter-r-w" class="header-anchor">#</a> FF05 - TIMA - Timer counter (R/W)</h4> <p>This timer is incremented by a clock frequency specified by the TAC
register ($FF07). When the value overflows (gets bigger than FFh) then
it will be reset to the value specified in TMA (FF06), and an interrupt
will be requested, as described below.</p> <h4 id="ff06-tma-timer-modulo-r-w"><a href="#ff06-tma-timer-modulo-r-w" class="header-anchor">#</a> FF06 - TMA - Timer Modulo (R/W)</h4> <p>When the TIMA overflows, this data will be loaded.</p> <h4 id="ff07-tac-timer-control-r-w"><a href="#ff07-tac-timer-control-r-w" class="header-anchor">#</a> FF07 - TAC - Timer Control (R/W)</h4> <div class="language- extra-class"><pre class="language-text"><code>Bit  2   - Timer Enable
Bits 1-0 - Input Clock Select
           00: CPU Clock / 1024 (DMG, CGB:   4096 Hz, SGB:   ~4194 Hz)
           01: CPU Clock / 16   (DMG, CGB: 262144 Hz, SGB: ~268400 Hz)
           10: CPU Clock / 64   (DMG, CGB:  65536 Hz, SGB:  ~67110 Hz)
           11: CPU Clock / 256  (DMG, CGB:  16384 Hz, SGB:  ~16780 Hz)
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">NOTE</p> <p>The &quot;Timer Enable&quot; bit only affects the timer, the divider is <strong>always</strong> counting</p></div> <h4 id="int-50-timer-interrupt"><a href="#int-50-timer-interrupt" class="header-anchor">#</a> INT 50 - Timer Interrupt</h4> <p>Each time when the timer overflows (ie. when TIMA gets bigger than FFh),
then an interrupt is requested by setting Bit 2 in the IF Register
(FF0F). When that interrupt is enabled, then the CPU will execute it by
calling the timer interrupt vector at 0050h.</p> <h4 id="timer-obscure-behaviour"><a href="#timer-obscure-behaviour" class="header-anchor">#</a> Timer Obscure Behaviour</h4> <p>Read this page for a more detailed description of what the registers do:
<a href="Timer_Obscure_Behaviour" title="wikilink">Timer Obscure Behaviour</a></p> <div class="custom-block tip"><p class="custom-block-title">NOTE</p> <p>The above described Timer is the built-in timer in the gameboy. It has
nothing to do with the MBC3s battery buffered Real Time Clock - that's
a completely different thing, described in the chapter about Memory
Banking Controllers.</p></div> <h1 id="interrupts"><a href="#interrupts" class="header-anchor">#</a> Interrupts</h1> <h4 id="ime-interrupt-master-enable-flag-write-only"><a href="#ime-interrupt-master-enable-flag-write-only" class="header-anchor">#</a> IME - Interrupt Master Enable Flag (Write Only)</h4> <div class="language- extra-class"><pre class="language-text"><code>0 - Disable all Interrupts
1 - Enable all Interrupts that are enabled in IE Register (FFFF)
</code></pre></div><p>The IME flag is used to disable all interrupts, overriding any enabled
bits in the IE Register. It isn't possible to access the IME flag by
using a I/O address, instead IME is accessed directly from the CPU, by
the following opcodes/operations:</p> <div class="language- extra-class"><pre class="language-text"><code>EI     ;Enable Interrupts  (ie. IME=1)
DI     ;Disable Interrupts (ie. IME=0)
RETI   ;Enable Ints &amp; Return (same as the opcode combination EI, RET)
&lt;INT&gt;  ;Disable Ints &amp; Call to Interrupt Vector
</code></pre></div><p>Whereas &lt;INT&gt; means the operation which is automatically executed by the
CPU when it executes an interrupt.</p> <p>The effect of EI is delayed by one instruction. This means that EI
followed immediately by DI does not allow interrupts between the EI and
the DI.</p> <h4 id="ffff-ie-interrupt-enable-r-w"><a href="#ffff-ie-interrupt-enable-r-w" class="header-anchor">#</a> FFFF - IE - Interrupt Enable (R/W)</h4> <div class="language- extra-class"><pre class="language-text"><code>Bit 0: V-Blank  Interrupt Enable  (INT 40h)  (1=Enable)
Bit 1: LCD STAT Interrupt Enable  (INT 48h)  (1=Enable)
Bit 2: Timer    Interrupt Enable  (INT 50h)  (1=Enable)
Bit 3: Serial   Interrupt Enable  (INT 58h)  (1=Enable)
Bit 4: Joypad   Interrupt Enable  (INT 60h)  (1=Enable)
</code></pre></div><h4 id="ff0f-if-interrupt-flag-r-w"><a href="#ff0f-if-interrupt-flag-r-w" class="header-anchor">#</a> FF0F - IF - Interrupt Flag (R/W)</h4> <div class="language- extra-class"><pre class="language-text"><code>Bit 0: V-Blank  Interrupt Request (INT 40h)  (1=Request)
Bit 1: LCD STAT Interrupt Request (INT 48h)  (1=Request)
Bit 2: Timer    Interrupt Request (INT 50h)  (1=Request)
Bit 3: Serial   Interrupt Request (INT 58h)  (1=Request)
Bit 4: Joypad   Interrupt Request (INT 60h)  (1=Request)
</code></pre></div><p>When an interrupt signal changes from low to high, then the
corresponding bit in the IF register becomes set. For example, Bit 0
becomes set when the LCD controller enters into the V-Blank period.</p> <h4 id="interrupt-requests"><a href="#interrupt-requests" class="header-anchor">#</a> Interrupt Requests</h4> <p>Any set bits in the IF register are only <strong>requesting</strong> an interrupt to be
executed. The actual <strong>execution</strong> happens only if both the IME flag, and
the corresponding bit in the IE register are set, otherwise the
interrupt 'waits' until both IME and IE allow its execution.</p> <h4 id="interrupt-execution"><a href="#interrupt-execution" class="header-anchor">#</a> Interrupt Execution</h4> <p>When an interrupt gets executed, the corresponding bit in the IF
register becomes automatically reset by the CPU, and the IME flag
becomes cleared (disabeling any further interrupts until the program
re-enables the interrupts, typically by using the RETI instruction), and
the corresponding Interrupt Vector (that are the addresses in range
0040h-0060h, as shown in IE and IF register decriptions above) becomes
called.</p> <h4 id="manually-requesting-discarding-interrupts"><a href="#manually-requesting-discarding-interrupts" class="header-anchor">#</a> Manually Requesting/Discarding Interrupts</h4> <p>As the CPU automatically sets and cleares the bits in the IF register it
is usually not required to write to the IF register. However, the user
may still do that in order to manually request (or discard) interrupts.
As for real interrupts, a manually requested interrupt isn't executed
unless/until IME and IE allow its execution.</p> <h4 id="interrupt-priorities"><a href="#interrupt-priorities" class="header-anchor">#</a> Interrupt Priorities</h4> <p>In the following three situations it might happen that more than 1 bit in the IF register are set, requesting more than one interrupt at once:</p> <ol><li>More than one interrupt signal changed from Low to High at the same time.</li> <li>Several interrupts have been requested during a time in which IME/IE didn't allow these interrupts to be executed directly.</li> <li>The user has written a value with several &quot;1&quot; bits (for example 1Fh) to the IF register.</li></ol> <p>Provided that IME and IE allow the execution of more than one of the
requested interrupts, then the interrupt with the highest priority
becomes executed first. The priorities are ordered as the bits in the IE
and IF registers, Bit 0 (V-Blank) having the highest priority, and Bit 4
(Joypad) having the lowest priority.</p> <h4 id="nested-interrupts"><a href="#nested-interrupts" class="header-anchor">#</a> Nested Interrupts</h4> <p>The CPU automatically disables all other interrupts by setting IME=0
when it executes an interrupt. Usually IME remains zero until the
interrupt procedure returns (and sets IME=1 by the RETI instruction).
However, if you want any other interrupts of lower or higher (or same)
priority to be allowed to be executed from inside of the interrupt
procedure, then you can place an EI instruction into the interrupt
procedure.</p> <h4 id="interrupt-service-routine"><a href="#interrupt-service-routine" class="header-anchor">#</a> Interrupt Service Routine</h4> <p>According to Z80 datasheets, the following occurs when control is being
transferred to an interrupt handler:</p> <ol><li>Two wait states are executed (2 machine cycles pass while nothing
occurs, presumably the CPU is executing NOPs during this time).</li> <li>The current PC is pushed onto the stack, this process consumes 2 more
machine cycles.</li> <li>The high byte of the PC is set to 0, the low byte is set to the
address of the handler ($40,$48,$50,$58,$60). This consumes one
last machine cycle.</li></ol> <p>The entire ISR <strong>should</strong> consume a total of 5 machine cycles. This has
yet to be tested, but is what the Z80 datasheet implies.</p> <h1 id="mbc1"><a href="#mbc1" class="header-anchor">#</a> MBC1</h1> <p>(max 2MByte ROM and/or 32KByte RAM)</p> <p>This is the first MBC chip for the gameboy. Any newer MBC chips are
working similiar, so that is relative easy to upgrade a program from one
MBC chip to another - or even to make it compatible to several different
types of MBCs.</p> <p>Note that the memory in range 0000-7FFF is used for both reading from
ROM, and for writing to the MBCs Control Registers.</p> <h4 id="_0000-3fff-rom-bank-00-read-only"><a href="#_0000-3fff-rom-bank-00-read-only" class="header-anchor">#</a> 0000-3FFF - ROM Bank 00 (Read Only)</h4> <p>This area always contains the first 16KBytes of the cartridge ROM.</p> <h4 id="_4000-7fff-rom-bank-01-7f-read-only"><a href="#_4000-7fff-rom-bank-01-7f-read-only" class="header-anchor">#</a> 4000-7FFF - ROM Bank 01-7F (Read Only)</h4> <p>This area may contain any of the further 16KByte banks of the ROM,
allowing to address up to 125 ROM Banks (almost 2MByte). As described
below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the
odd amount of 125 banks.</p> <h4 id="a000-bfff-ram-bank-00-03-if-any-read-write"><a href="#a000-bfff-ram-bank-00-03-if-any-read-write" class="header-anchor">#</a> A000-BFFF - RAM Bank 00-03, if any (Read/Write)</h4> <p>This area is used to address external RAM in the cartridge (if any).
External RAM is often battery buffered, allowing to store game positions
or high score tables, even if the Game Boy is turned off, or if the
cartridge is removed from the gameboy. Available RAM sizes are: 2KByte
(at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K
banks at A000-BFFF).</p> <h4 id="_0000-1fff-ram-enable-write-only"><a href="#_0000-1fff-ram-enable-write-only" class="header-anchor">#</a> 0000-1FFF - RAM Enable (Write Only)</h4> <p>Before external RAM can be read or written, it must be enabled by
writing to this address space. It is recommended to disable external RAM
after accessing it, in order to protect its contents from damage during
power down of the gameboy. Usually the following values are used:</p> <div class="language- extra-class"><pre class="language-text"><code>00h  Disable RAM (default)
0Ah  Enable RAM`
</code></pre></div><p>Practically any value with 0Ah in the lower 4 bits enables RAM, and any
other value disables RAM.</p> <h4 id="_2000-3fff-rom-bank-number-write-only"><a href="#_2000-3fff-rom-bank-number-write-only" class="header-anchor">#</a> 2000-3FFF - ROM Bank Number (Write Only)</h4> <p>Writing to this address space selects the lower 5 bits of the ROM Bank
Number (in range 01-1Fh). When 00h is written, the MBC translates that
to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be
always directly accessed by reading from 0000-3FFF. But (when using the
register below to specify the upper ROM Bank bits), the same happens for
Bank 20h, 40h, and 60h. Any attempt to address these ROM Banks will
select Bank 21h, 41h, and 61h instead.</p> <h4 id="_4000-5fff-ram-bank-number-or-upper-bits-of-rom-bank-number-write-only"><a href="#_4000-5fff-ram-bank-number-or-upper-bits-of-rom-bank-number-write-only" class="header-anchor">#</a> 4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)</h4> <p>This 2bit register can be used to select a RAM Bank in range from
00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank
number, depending on the current ROM/RAM Mode. (See below.)</p> <h4 id="_6000-7fff-rom-ram-mode-select-write-only"><a href="#_6000-7fff-rom-ram-mode-select-write-only" class="header-anchor">#</a> 6000-7FFF - ROM/RAM Mode Select (Write Only)</h4> <p>This 1bit Register selects whether the two bits of the above register
should be used as upper two bits of the ROM Bank, or as RAM Bank Number.</p> <div class="language- extra-class"><pre class="language-text"><code>00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)
</code></pre></div><p>The program may freely switch between both modes, the only limitiation
is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks
00-1Fh can be used during Mode 1.</p> <h1 id="power-up-sequence"><a href="#power-up-sequence" class="header-anchor">#</a> Power Up Sequence</h1> <p>When the Game Boy is powered up, a 256 byte program starting at memory location 0 is executed. This program is located in a ROM inside the GameBoy. The first thing the program does is read the cartridge locations from $104 to $133 and place this graphic of a Nintendo logo on the screen at the top.</p> <p>This image is then scrolled until it is in the middle of the screen. Two musical notes are then played on the internal speaker. Again, the cartridge locations $104 to $133 are read but this time they are compared with a table in the internal rom.</p> <p>If any byte fails to compare, then the Game Boy stops comparing bytes and simply halts all operations.</p> <p>If all locations compare the same, then the GameBoy starts adding all of the bytes in the cartridge from $134 to $14d. A value of 25 decimal is added to this total.</p> <p>If the least significant byte of the result is a not a zero, then the Game Boy will stop doing anything.</p> <p>If it is a zero, then the internal ROM is disabled and cartridge program execution begins at location $100 with the following register values:</p> <div class="language- extra-class"><pre class="language-text"><code>  AF=$01B0
  BC=$0013
  DE=$00D8
  HL=$014D
  Stack Pointer=$FFFE
  [$FF05] = $00   ; TIMA
  [$FF06] = $00   ; TMA
  [$FF07] = $00   ; TAC
  [$FF10] = $80   ; NR10
  [$FF11] = $BF   ; NR11
  [$FF12] = $F3   ; NR12
  [$FF14] = $BF   ; NR14
  [$FF16] = $3F   ; NR21
  [$FF17] = $00   ; NR22
  [$FF19] = $BF   ; NR24
  [$FF1A] = $7F   ; NR30
  [$FF1B] = $FF   ; NR31
  [$FF1C] = $9F   ; NR32
  [$FF1E] = $BF   ; NR33
  [$FF20] = $FF   ; NR41
  [$FF21] = $00   ; NR42
  [$FF22] = $00   ; NR43
  [$FF23] = $BF   ; NR44
  [$FF24] = $77   ; NR50
  [$FF25] = $F3   ; NR51
  [$FF26] = $F1-GB, $F0-SGB ; NR52
  [$FF40] = $91   ; LCDC
  [$FF42] = $00   ; SCY
  [$FF43] = $00   ; SCX
  [$FF45] = $00   ; LYC
  [$FF47] = $FC   ; BGP
  [$FF48] = $FF   ; OBP0
  [$FF49] = $FF   ; OBP1
  [$FF4A] = $00   ; WY
  [$FF4B] = $00   ; WX
  [$FFFF] = $00   ; IE
</code></pre></div><p>It is not a good idea to assume the above values will always exist. A later version Game Boy could contain different values than these at reset. Always set these registers on reset rather than assume they are as above.</p> <p>Please note that Game Boy internal RAM on power up contains random data.</p> <p>All of the Game Boy emulators tend to set all RAM to value $00 on entry.</p> <p>Cart RAM the first time it is accessed on a real Game Boy contains random data.
It will only contain known data if the Game Boy code initializes it to some value.</p> <h3 id="references"><a href="#references" class="header-anchor">#</a> References</h3> <ul><li><a href="https://github.com/AntonioND/giibiiadvance/tree/master/docs" target="_blank" rel="noopener noreferrer">Antonio Niño Díaz (AntonioND). The Cycle-Accurate Game Boy Docs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://www.its.caltech.edu/~costis/sgb_hack/" target="_blank" rel="noopener noreferrer">Costis Sideris. The quest for dumping GameBoy Boot ROMs!<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://wiki.tauwasser.eu/view/MBC1" target="_blank" rel="noopener noreferrer">Tauwasser. MBC1 - Tauwasser’s Wiki<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://wiki.tauwasser.eu/view/MBC2" target="_blank" rel="noopener noreferrer">Tauwasser. MBC2 - Tauwasser’s Wiki<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/Gekkio/gb-ctr" target="_blank" rel="noopener noreferrer">Gekkio. Game Boy: Complete Technical Reference<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://gbdev.github.io/gb-opcodes/optables/" target="_blank" rel="noopener noreferrer">Game Boy CPU (SM83) instruction set<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://gekkio.fi/blog/2015/dumping-the-super-game-boy-2-boot-rom/" target="_blank" rel="noopener noreferrer">Gekkio. Dumping the Super Game Boy 2 boot ROM<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://exez.in/gameboy-dma" target="_blank" rel="noopener noreferrer">exezin. OAM DMA tutorial<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/pandocs/assets/js/app.4b9c9e14.js" defer></script><script src="/pandocs/assets/js/3.996332f8.js" defer></script><script src="/pandocs/assets/js/2.0dbba3d2.js" defer></script><script src="/pandocs/assets/js/7.6c343c2b.js" defer></script>
  </body>
</html>
